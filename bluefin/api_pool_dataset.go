/*
TrueNAS RESTful API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package bluefin

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// PoolDatasetApiService PoolDatasetApi service
type PoolDatasetApiService service

type ApiPoolDatasetChangeKeyPostRequest struct {
	ctx                  context.Context
	ApiService           *PoolDatasetApiService
	poolDatasetChangeKey *PoolDatasetChangeKey
}

func (r ApiPoolDatasetChangeKeyPostRequest) PoolDatasetChangeKey(poolDatasetChangeKey PoolDatasetChangeKey) ApiPoolDatasetChangeKeyPostRequest {
	r.poolDatasetChangeKey = &poolDatasetChangeKey
	return r
}

func (r ApiPoolDatasetChangeKeyPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.PoolDatasetChangeKeyPostExecute(r)
}

/*
PoolDatasetChangeKeyPost Method for PoolDatasetChangeKeyPost

Change encryption properties for `id` encrypted dataset.

Changing dataset encryption to use passphrase instead of a key is not allowed if:

1) It has encrypted roots as children which are encrypted with a key
2) If it is a root dataset where the system dataset is located

A file might be uploaded to this endpoint. To upload a file, please send a multipart request with two parts. The first, named `data`, should contain a JSON-encoded payload, and the second, named `file`, should contain an uploaded file.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPoolDatasetChangeKeyPostRequest
*/
func (a *PoolDatasetApiService) PoolDatasetChangeKeyPost(ctx context.Context) ApiPoolDatasetChangeKeyPostRequest {
	return ApiPoolDatasetChangeKeyPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PoolDatasetApiService) PoolDatasetChangeKeyPostExecute(r ApiPoolDatasetChangeKeyPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetChangeKeyPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/change_key"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.poolDatasetChangeKey
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetChecksumChoicesGetRequest struct {
	ctx        context.Context
	ApiService *PoolDatasetApiService
}

func (r ApiPoolDatasetChecksumChoicesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.PoolDatasetChecksumChoicesGetExecute(r)
}

/*
PoolDatasetChecksumChoicesGet Method for PoolDatasetChecksumChoicesGet

Retrieve checksums supported for ZFS dataset.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPoolDatasetChecksumChoicesGetRequest
*/
func (a *PoolDatasetApiService) PoolDatasetChecksumChoicesGet(ctx context.Context) ApiPoolDatasetChecksumChoicesGetRequest {
	return ApiPoolDatasetChecksumChoicesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PoolDatasetApiService) PoolDatasetChecksumChoicesGetExecute(r ApiPoolDatasetChecksumChoicesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetChecksumChoicesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/checksum_choices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetCompressionChoicesGetRequest struct {
	ctx        context.Context
	ApiService *PoolDatasetApiService
}

func (r ApiPoolDatasetCompressionChoicesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.PoolDatasetCompressionChoicesGetExecute(r)
}

/*
PoolDatasetCompressionChoicesGet Method for PoolDatasetCompressionChoicesGet

Retrieve compression algorithm supported by ZFS.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPoolDatasetCompressionChoicesGetRequest
*/
func (a *PoolDatasetApiService) PoolDatasetCompressionChoicesGet(ctx context.Context) ApiPoolDatasetCompressionChoicesGetRequest {
	return ApiPoolDatasetCompressionChoicesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PoolDatasetApiService) PoolDatasetCompressionChoicesGetExecute(r ApiPoolDatasetCompressionChoicesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetCompressionChoicesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/compression_choices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetDestroySnapshotsPostRequest struct {
	ctx                         context.Context
	ApiService                  *PoolDatasetApiService
	poolDatasetDestroySnapshots *PoolDatasetDestroySnapshots
}

func (r ApiPoolDatasetDestroySnapshotsPostRequest) PoolDatasetDestroySnapshots(poolDatasetDestroySnapshots PoolDatasetDestroySnapshots) ApiPoolDatasetDestroySnapshotsPostRequest {
	r.poolDatasetDestroySnapshots = &poolDatasetDestroySnapshots
	return r
}

func (r ApiPoolDatasetDestroySnapshotsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.PoolDatasetDestroySnapshotsPostExecute(r)
}

/*
PoolDatasetDestroySnapshotsPost Method for PoolDatasetDestroySnapshotsPost

Destroy specified snapshots of a given dataset.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPoolDatasetDestroySnapshotsPostRequest
*/
func (a *PoolDatasetApiService) PoolDatasetDestroySnapshotsPost(ctx context.Context) ApiPoolDatasetDestroySnapshotsPostRequest {
	return ApiPoolDatasetDestroySnapshotsPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PoolDatasetApiService) PoolDatasetDestroySnapshotsPostExecute(r ApiPoolDatasetDestroySnapshotsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetDestroySnapshotsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/destroy_snapshots"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.poolDatasetDestroySnapshots
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetDetailsGetRequest struct {
	ctx        context.Context
	ApiService *PoolDatasetApiService
}

func (r ApiPoolDatasetDetailsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.PoolDatasetDetailsGetExecute(r)
}

/*
PoolDatasetDetailsGet Method for PoolDatasetDetailsGet

Retrieve all dataset(s) details outlining any services/tasks which might be consuming the dataset(s).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPoolDatasetDetailsGetRequest
*/
func (a *PoolDatasetApiService) PoolDatasetDetailsGet(ctx context.Context) ApiPoolDatasetDetailsGetRequest {
	return ApiPoolDatasetDetailsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PoolDatasetApiService) PoolDatasetDetailsGetExecute(r ApiPoolDatasetDetailsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetDetailsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetEncryptionAlgorithmChoicesGetRequest struct {
	ctx        context.Context
	ApiService *PoolDatasetApiService
}

func (r ApiPoolDatasetEncryptionAlgorithmChoicesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.PoolDatasetEncryptionAlgorithmChoicesGetExecute(r)
}

/*
PoolDatasetEncryptionAlgorithmChoicesGet Method for PoolDatasetEncryptionAlgorithmChoicesGet

Retrieve encryption algorithms supported for ZFS dataset encryption.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPoolDatasetEncryptionAlgorithmChoicesGetRequest
*/
func (a *PoolDatasetApiService) PoolDatasetEncryptionAlgorithmChoicesGet(ctx context.Context) ApiPoolDatasetEncryptionAlgorithmChoicesGetRequest {
	return ApiPoolDatasetEncryptionAlgorithmChoicesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PoolDatasetApiService) PoolDatasetEncryptionAlgorithmChoicesGetExecute(r ApiPoolDatasetEncryptionAlgorithmChoicesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetEncryptionAlgorithmChoicesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/encryption_algorithm_choices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetEncryptionSummaryPostRequest struct {
	ctx                          context.Context
	ApiService                   *PoolDatasetApiService
	poolDatasetEncryptionSummary *PoolDatasetEncryptionSummary
}

func (r ApiPoolDatasetEncryptionSummaryPostRequest) PoolDatasetEncryptionSummary(poolDatasetEncryptionSummary PoolDatasetEncryptionSummary) ApiPoolDatasetEncryptionSummaryPostRequest {
	r.poolDatasetEncryptionSummary = &poolDatasetEncryptionSummary
	return r
}

func (r ApiPoolDatasetEncryptionSummaryPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.PoolDatasetEncryptionSummaryPostExecute(r)
}

/*
PoolDatasetEncryptionSummaryPost Method for PoolDatasetEncryptionSummaryPost

Retrieve summary of all encrypted roots under `id`.

Keys/passphrase can be supplied to check if the keys are valid.

It should be noted that there are 2 keys which show if a recursive unlock operation is
done for `id`, which dataset will be unlocked and if not why it won't be unlocked. The keys
namely are "unlock_successful" and "unlock_error". The former is a boolean value showing if unlock
would succeed/fail. The latter is description why it failed if it failed.

In some cases it's possible that the provided key/passphrase is valid but the path where the dataset is
supposed to be mounted after being unlocked already exists and is not empty. In this case, unlock operation
would fail and `unlock_error` will reflect this error appropriately. This can be overridden by setting
`encryption_root_summary_options.datasets.X.force` boolean flag or by setting
`encryption_root_summary_options.force` flag. In practice, when the dataset is going to be unlocked
and these flags have been provided to `pool.dataset.unlock`, system will rename the directory/file path
where the dataset should be mounted resulting in successful unlock of the dataset.

If a dataset is already unlocked, it will show up as true for "unlock_successful" regardless of what
key user provided as the unlock keys in the output are to reflect what a real unlock operation would
behave. If user is interested in seeing if a provided key is valid or not, then the key to look out for
in the output is "valid_key" which based on what system has in database or if a user provided one, validates
the key and sets a boolean value for the dataset.

Example output:
[

	{
	    "name": "vol",
	    "key_format": "PASSPHRASE",
	    "key_present_in_database": false,
	    "valid_key": true,
	    "locked": true,
	    "unlock_error": null,
	    "unlock_successful": true
	},
	{
	    "name": "vol/c1/d1",
	    "key_format": "PASSPHRASE",
	    "key_present_in_database": false,
	    "valid_key": false,
	    "locked": true,
	    "unlock_error": "Provided key is invalid",
	    "unlock_successful": false
	},
	{
	    "name": "vol/c",
	    "key_format": "PASSPHRASE",
	    "key_present_in_database": false,
	    "valid_key": false,
	    "locked": true,
	    "unlock_error": "Key not provided",
	    "unlock_successful": false
	},
	{
	    "name": "vol/c/d2",
	    "key_format": "PASSPHRASE",
	    "key_present_in_database": false,
	    "valid_key": false,
	    "locked": true,
	    "unlock_error": "Child cannot be unlocked when parent "vol/c" is locked and provided key is invalid",
	    "unlock_successful": false
	}

]

A file might be uploaded to this endpoint. To upload a file, please send a multipart request with two parts. The first, named `data`, should contain a JSON-encoded payload, and the second, named `file`, should contain an uploaded file.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPoolDatasetEncryptionSummaryPostRequest
*/
func (a *PoolDatasetApiService) PoolDatasetEncryptionSummaryPost(ctx context.Context) ApiPoolDatasetEncryptionSummaryPostRequest {
	return ApiPoolDatasetEncryptionSummaryPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PoolDatasetApiService) PoolDatasetEncryptionSummaryPostExecute(r ApiPoolDatasetEncryptionSummaryPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetEncryptionSummaryPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/encryption_summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.poolDatasetEncryptionSummary
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetExportKeyPostRequest struct {
	ctx                  context.Context
	ApiService           *PoolDatasetApiService
	poolDatasetExportKey *PoolDatasetExportKey
}

func (r ApiPoolDatasetExportKeyPostRequest) PoolDatasetExportKey(poolDatasetExportKey PoolDatasetExportKey) ApiPoolDatasetExportKeyPostRequest {
	r.poolDatasetExportKey = &poolDatasetExportKey
	return r
}

func (r ApiPoolDatasetExportKeyPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.PoolDatasetExportKeyPostExecute(r)
}

/*
PoolDatasetExportKeyPost Method for PoolDatasetExportKeyPost

Export own encryption key for dataset `id`. If `download` is `true`, key will be downloaded in a json file
where the same file can be used to unlock the dataset, otherwise it will be returned as string.

Please refer to websocket documentation for downloading the file.

A file might be downloaded from this endpoint. Please specify `?download=0` to fetch a method call result instead.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPoolDatasetExportKeyPostRequest
*/
func (a *PoolDatasetApiService) PoolDatasetExportKeyPost(ctx context.Context) ApiPoolDatasetExportKeyPostRequest {
	return ApiPoolDatasetExportKeyPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PoolDatasetApiService) PoolDatasetExportKeyPostExecute(r ApiPoolDatasetExportKeyPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetExportKeyPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/export_key"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.poolDatasetExportKey
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetExportKeysPostRequest struct {
	ctx        context.Context
	ApiService *PoolDatasetApiService
	body       *string
}

func (r ApiPoolDatasetExportKeysPostRequest) Body(body string) ApiPoolDatasetExportKeysPostRequest {
	r.body = &body
	return r
}

func (r ApiPoolDatasetExportKeysPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.PoolDatasetExportKeysPostExecute(r)
}

/*
PoolDatasetExportKeysPost Method for PoolDatasetExportKeysPost

Export keys for `id` and its children which are stored in the system. The exported file is a JSON file
which has a dictionary containing dataset names as keys and their keys as the value.

Please refer to websocket documentation for downloading the file.

A file will be downloaded from this endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPoolDatasetExportKeysPostRequest
*/
func (a *PoolDatasetApiService) PoolDatasetExportKeysPost(ctx context.Context) ApiPoolDatasetExportKeysPostRequest {
	return ApiPoolDatasetExportKeysPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PoolDatasetApiService) PoolDatasetExportKeysPostExecute(r ApiPoolDatasetExportKeysPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetExportKeysPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/export_keys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetGetRequest struct {
	ctx        context.Context
	ApiService *PoolDatasetApiService
	limit      *int32
	offset     *int32
	count      *bool
	sort       *string
}

func (r ApiPoolDatasetGetRequest) Limit(limit int32) ApiPoolDatasetGetRequest {
	r.limit = &limit
	return r
}

func (r ApiPoolDatasetGetRequest) Offset(offset int32) ApiPoolDatasetGetRequest {
	r.offset = &offset
	return r
}

func (r ApiPoolDatasetGetRequest) Count(count bool) ApiPoolDatasetGetRequest {
	r.count = &count
	return r
}

func (r ApiPoolDatasetGetRequest) Sort(sort string) ApiPoolDatasetGetRequest {
	r.sort = &sort
	return r
}

func (r ApiPoolDatasetGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.PoolDatasetGetExecute(r)
}

/*
PoolDatasetGet Method for PoolDatasetGet

Query Pool Datasets with `query-filters` and `query-options`.

We provide two ways to retrieve datasets. The first is a flat structure (default), where
all datasets in the system are returned as separate objects which contain all data
there is for their children. This retrieval type is slightly slower because of duplicates in each object.
The second type is hierarchical, where only top level datasets are returned in the list. They contain all the
children in the `children` key. This retrieval type is slightly faster.
These options are controlled by the `query-options.extra.flat` attribute (default true).

In some cases it might be desirable to only retrieve details of a dataset itself and not it's children, in this
case `query-options.extra.retrieve_children` should be explicitly specified and set to `false` which will
result in children not being retrieved.

In case only some properties are desired to be retrieved for datasets, consumer should specify
`query-options.extra.properties` which when `null` ( which is the default ) will retrieve all properties
and otherwise a list can be specified like `["type", "used", "available"]` to retrieve selective properties.
If no properties are desired, in that case an empty list should be sent.

`query-options.extra.snapshots` can be set to retrieve snapshot(s) of dataset in question.

`query-options.extra.snapshots_recursive` can be set to retrieve snapshot(s) recursively of dataset in question.
If `query-options.extra.snapshots_recursive` and `query-options.extra.snapshots` are set, snapshot(s) will be
retrieved recursively.

`query-options.extra.snapshots_properties` can be specified to list out properties which should be retrieved
for snapshot(s) related to each dataset. By default only name of the snapshot would be retrieved, however
if `null` is specified all properties of the snapshot would be retrieved in this case.

`query-options.extra` can be specified as query parameters with prefixing them with `extra.` prefix. For example, `extra.retrieve_properties=false` will pass `retrieve_properties` as an extra argument to pool/dataset endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPoolDatasetGetRequest
*/
func (a *PoolDatasetApiService) PoolDatasetGet(ctx context.Context) ApiPoolDatasetGetRequest {
	return ApiPoolDatasetGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PoolDatasetApiService) PoolDatasetGetExecute(r ApiPoolDatasetGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetGetInstancePostRequest struct {
	ctx                    context.Context
	ApiService             *PoolDatasetApiService
	poolDatasetGetInstance *PoolDatasetGetInstance
}

func (r ApiPoolDatasetGetInstancePostRequest) PoolDatasetGetInstance(poolDatasetGetInstance PoolDatasetGetInstance) ApiPoolDatasetGetInstancePostRequest {
	r.poolDatasetGetInstance = &poolDatasetGetInstance
	return r
}

func (r ApiPoolDatasetGetInstancePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.PoolDatasetGetInstancePostExecute(r)
}

/*
PoolDatasetGetInstancePost Method for PoolDatasetGetInstancePost

Returns instance matching `id`. If `id` is not found, Validation error is raised.

Please see `query` method documentation for `options`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPoolDatasetGetInstancePostRequest
*/
func (a *PoolDatasetApiService) PoolDatasetGetInstancePost(ctx context.Context) ApiPoolDatasetGetInstancePostRequest {
	return ApiPoolDatasetGetInstancePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PoolDatasetApiService) PoolDatasetGetInstancePostExecute(r ApiPoolDatasetGetInstancePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetGetInstancePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/get_instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.poolDatasetGetInstance
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetIdIdAttachmentsPostRequest struct {
	ctx        context.Context
	ApiService *PoolDatasetApiService
	id         string
}

func (r ApiPoolDatasetIdIdAttachmentsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.PoolDatasetIdIdAttachmentsPostExecute(r)
}

/*
PoolDatasetIdIdAttachmentsPost Method for PoolDatasetIdIdAttachmentsPost

Return a list of services dependent of this dataset.

Responsible for telling the user whether there is a related
share, asking for confirmation.

Example return value:
[

	{
	  "type": "NFS Share",
	  "service": "nfs",
	  "attachments": ["/mnt/tank/work"]
	}

]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiPoolDatasetIdIdAttachmentsPostRequest
*/
func (a *PoolDatasetApiService) PoolDatasetIdIdAttachmentsPost(ctx context.Context, id string) ApiPoolDatasetIdIdAttachmentsPostRequest {
	return ApiPoolDatasetIdIdAttachmentsPostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *PoolDatasetApiService) PoolDatasetIdIdAttachmentsPostExecute(r ApiPoolDatasetIdIdAttachmentsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetIdIdAttachmentsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/id/{id}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetIdIdDeleteRequest struct {
	ctx        context.Context
	ApiService *PoolDatasetApiService
	id         string
}

func (r ApiPoolDatasetIdIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.PoolDatasetIdIdDeleteExecute(r)
}

/*
PoolDatasetIdIdDelete Method for PoolDatasetIdIdDelete

Delete dataset/zvol `id`.

`recursive` will also delete/destroy all children datasets.
`force` will force delete busy datasets.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiPoolDatasetIdIdDeleteRequest
*/
func (a *PoolDatasetApiService) PoolDatasetIdIdDelete(ctx context.Context, id string) ApiPoolDatasetIdIdDeleteRequest {
	return ApiPoolDatasetIdIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *PoolDatasetApiService) PoolDatasetIdIdDeleteExecute(r ApiPoolDatasetIdIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetIdIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetIdIdGetRequest struct {
	ctx        context.Context
	ApiService *PoolDatasetApiService
	id         string
}

func (r ApiPoolDatasetIdIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.PoolDatasetIdIdGetExecute(r)
}

/*
PoolDatasetIdIdGet Method for PoolDatasetIdIdGet

Query Pool Datasets with `query-filters` and `query-options`.

We provide two ways to retrieve datasets. The first is a flat structure (default), where
all datasets in the system are returned as separate objects which contain all data
there is for their children. This retrieval type is slightly slower because of duplicates in each object.
The second type is hierarchical, where only top level datasets are returned in the list. They contain all the
children in the `children` key. This retrieval type is slightly faster.
These options are controlled by the `query-options.extra.flat` attribute (default true).

In some cases it might be desirable to only retrieve details of a dataset itself and not it's children, in this
case `query-options.extra.retrieve_children` should be explicitly specified and set to `false` which will
result in children not being retrieved.

In case only some properties are desired to be retrieved for datasets, consumer should specify
`query-options.extra.properties` which when `null` ( which is the default ) will retrieve all properties
and otherwise a list can be specified like `["type", "used", "available"]` to retrieve selective properties.
If no properties are desired, in that case an empty list should be sent.

`query-options.extra.snapshots` can be set to retrieve snapshot(s) of dataset in question.

`query-options.extra.snapshots_recursive` can be set to retrieve snapshot(s) recursively of dataset in question.
If `query-options.extra.snapshots_recursive` and `query-options.extra.snapshots` are set, snapshot(s) will be
retrieved recursively.

`query-options.extra.snapshots_properties` can be specified to list out properties which should be retrieved
for snapshot(s) related to each dataset. By default only name of the snapshot would be retrieved, however
if `null` is specified all properties of the snapshot would be retrieved in this case.

`query-options.extra` can be specified as query parameters with prefixing them with `extra.` prefix. For example, `extra.retrieve_properties=false` will pass `retrieve_properties` as an extra argument to pool/dataset endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiPoolDatasetIdIdGetRequest
*/
func (a *PoolDatasetApiService) PoolDatasetIdIdGet(ctx context.Context, id string) ApiPoolDatasetIdIdGetRequest {
	return ApiPoolDatasetIdIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *PoolDatasetApiService) PoolDatasetIdIdGetExecute(r ApiPoolDatasetIdIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetIdIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetIdIdGetQuotaPostRequest struct {
	ctx        context.Context
	ApiService *PoolDatasetApiService
	id         string
}

func (r ApiPoolDatasetIdIdGetQuotaPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.PoolDatasetIdIdGetQuotaPostExecute(r)
}

/*
PoolDatasetIdIdGetQuotaPost Method for PoolDatasetIdIdGetQuotaPost

Return a list of the specified `quota_type` of quotas on the ZFS dataset `ds`.
Support `query-filters` and `query-options`. used_bytes may not instantly
update as space is used.

When quota_type is not DATASET, each quota entry has these fields:

`id` - the uid or gid to which the quota applies.

`name` - the user or group name to which the quota applies. Value is
null if the id in the quota cannot be resolved to a user or group. This
indicates that the user or group does not exist on the server.

`quota` - the quota size in bytes.  Absent if no quota is set.

`used_bytes` - the amount of bytes the user has written to the dataset.
A value of zero means unlimited.

`obj_quota` - the number of objects that may be owned by `id`.
A value of zero means unlimited.  Absent if no objquota is set.

`obj_used` - the number of objects currently owned by `id`.

Note: SMB client requests to set a quota granting no space will result
in an on-disk quota of 1 KiB.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiPoolDatasetIdIdGetQuotaPostRequest
*/
func (a *PoolDatasetApiService) PoolDatasetIdIdGetQuotaPost(ctx context.Context, id string) ApiPoolDatasetIdIdGetQuotaPostRequest {
	return ApiPoolDatasetIdIdGetQuotaPostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *PoolDatasetApiService) PoolDatasetIdIdGetQuotaPostExecute(r ApiPoolDatasetIdIdGetQuotaPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetIdIdGetQuotaPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/id/{id}/get_quota"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetIdIdPermissionPostRequest struct {
	ctx        context.Context
	ApiService *PoolDatasetApiService
	id         string
}

func (r ApiPoolDatasetIdIdPermissionPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.PoolDatasetIdIdPermissionPostExecute(r)
}

/*
PoolDatasetIdIdPermissionPost Method for PoolDatasetIdIdPermissionPost

Set permissions for a dataset `id`. Permissions may be specified as
either a posix `mode` or an `acl`. This method is a wrapper around
`filesystem.setperm`, `filesystem.setacl`, and `filesystem.chown`

`filesystem.setperm` is called if `mode` is specified.
`filesystem.setacl` is called if `acl` is specified or if the
option `set_default_acl` is selected.
`filesystem.chown` is called if neither `mode` nor `acl` is
specified.

The following `options` are supported:

`set_default_acl` - apply a default ACL appropriate for specified
dataset. Default ACL is `NFS4_RESTRICTED` or `POSIX_RESTRICTED`
ACL template builtin with additional entries builtin_users group
and builtin_administrators group. See documentation for
`filesystem.acltemplate` for more details.

`stripacl` - this option must be set in order to apply a POSIX
mode to a dataset that has a non-trivial ACL. The effect will
be to remove existing ACL and replace with specified mode.

`recursive` - apply permissions recursively to dataset (all files
and directories will be impacted.

`traverse` - permit recursive job to traverse filesystem boundaries
(child datasets).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiPoolDatasetIdIdPermissionPostRequest
*/
func (a *PoolDatasetApiService) PoolDatasetIdIdPermissionPost(ctx context.Context, id string) ApiPoolDatasetIdIdPermissionPostRequest {
	return ApiPoolDatasetIdIdPermissionPostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *PoolDatasetApiService) PoolDatasetIdIdPermissionPostExecute(r ApiPoolDatasetIdIdPermissionPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetIdIdPermissionPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/id/{id}/permission"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetIdIdProcessesPostRequest struct {
	ctx        context.Context
	ApiService *PoolDatasetApiService
	id         string
}

func (r ApiPoolDatasetIdIdProcessesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.PoolDatasetIdIdProcessesPostExecute(r)
}

/*
PoolDatasetIdIdProcessesPost Method for PoolDatasetIdIdProcessesPost

Return a list of processes using this dataset.

Example return value:

[

	{
	  "pid": 2520,
	  "name": "smbd",
	  "service": "cifs"
	},
	{
	  "pid": 97778,
	  "name": "minio",
	  "cmdline": "/usr/local/bin/minio -C /usr/local/etc/minio server --address=0.0.0.0:9000 --quiet /mnt/tank/wk"
	}

]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiPoolDatasetIdIdProcessesPostRequest
*/
func (a *PoolDatasetApiService) PoolDatasetIdIdProcessesPost(ctx context.Context, id string) ApiPoolDatasetIdIdProcessesPostRequest {
	return ApiPoolDatasetIdIdProcessesPostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *PoolDatasetApiService) PoolDatasetIdIdProcessesPostExecute(r ApiPoolDatasetIdIdProcessesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetIdIdProcessesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/id/{id}/processes"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetIdIdPromotePostRequest struct {
	ctx        context.Context
	ApiService *PoolDatasetApiService
	id         string
}

func (r ApiPoolDatasetIdIdPromotePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.PoolDatasetIdIdPromotePostExecute(r)
}

/*
PoolDatasetIdIdPromotePost Method for PoolDatasetIdIdPromotePost

Promote the cloned dataset `id`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiPoolDatasetIdIdPromotePostRequest
*/
func (a *PoolDatasetApiService) PoolDatasetIdIdPromotePost(ctx context.Context, id string) ApiPoolDatasetIdIdPromotePostRequest {
	return ApiPoolDatasetIdIdPromotePostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *PoolDatasetApiService) PoolDatasetIdIdPromotePostExecute(r ApiPoolDatasetIdIdPromotePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetIdIdPromotePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/id/{id}/promote"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetIdIdPutRequest struct {
	ctx        context.Context
	ApiService *PoolDatasetApiService
	id         string
}

func (r ApiPoolDatasetIdIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.PoolDatasetIdIdPutExecute(r)
}

/*
PoolDatasetIdIdPut Method for PoolDatasetIdIdPut

Updates a dataset/zvol `id`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiPoolDatasetIdIdPutRequest
*/
func (a *PoolDatasetApiService) PoolDatasetIdIdPut(ctx context.Context, id string) ApiPoolDatasetIdIdPutRequest {
	return ApiPoolDatasetIdIdPutRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *PoolDatasetApiService) PoolDatasetIdIdPutExecute(r ApiPoolDatasetIdIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetIdIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetIdIdSetQuotaPostRequest struct {
	ctx        context.Context
	ApiService *PoolDatasetApiService
	id         string
}

func (r ApiPoolDatasetIdIdSetQuotaPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.PoolDatasetIdIdSetQuotaPostExecute(r)
}

/*
PoolDatasetIdIdSetQuotaPost Method for PoolDatasetIdIdSetQuotaPost

There are three over-arching types of quotas for ZFS datasets.
1) dataset quotas and refquotas. If a DATASET quota type is specified in
this API call, then the API acts as a wrapper for `pool.dataset.update`.
2) User and group quotas. These limit the amount of disk space consumed
by files that are owned by the specified users or groups. If the respective
"object quota" type is specfied, then the quota limits the number of objects
that may be owned by the specified user or group.
3) Project quotas. These limit the amount of disk space consumed by files
that are owned by the specified project. Project quotas are not yet implemended.
This API allows users to set multiple quotas simultaneously by submitting a
list of quotas. The list may contain all supported quota types.
`ds` the name of the target ZFS dataset.
`quotas` specifies a list of `quota_entry` entries to apply to dataset.
`quota_entry` entries have these required parameters:
`quota_type`: specifies the type of quota to apply to the dataset. Possible
values are USER, USEROBJ, GROUP, GROUPOBJ, and DATASET. USEROBJ and GROUPOBJ
quotas limit the number of objects consumed by the specified user or group.
`id`: the uid, gid, or name to which the quota applies. If quota_type is
'DATASET', then `id` must be either `QUOTA` or `REFQUOTA`.
`quota_value`: the quota size in bytes. Setting a value of `0` removes
the user or group quota.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiPoolDatasetIdIdSetQuotaPostRequest
*/
func (a *PoolDatasetApiService) PoolDatasetIdIdSetQuotaPost(ctx context.Context, id string) ApiPoolDatasetIdIdSetQuotaPostRequest {
	return ApiPoolDatasetIdIdSetQuotaPostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *PoolDatasetApiService) PoolDatasetIdIdSetQuotaPostExecute(r ApiPoolDatasetIdIdSetQuotaPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetIdIdSetQuotaPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/id/{id}/set_quota"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetInheritParentEncryptionPropertiesPostRequest struct {
	ctx        context.Context
	ApiService *PoolDatasetApiService
	body       *string
}

func (r ApiPoolDatasetInheritParentEncryptionPropertiesPostRequest) Body(body string) ApiPoolDatasetInheritParentEncryptionPropertiesPostRequest {
	r.body = &body
	return r
}

func (r ApiPoolDatasetInheritParentEncryptionPropertiesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.PoolDatasetInheritParentEncryptionPropertiesPostExecute(r)
}

/*
PoolDatasetInheritParentEncryptionPropertiesPost Method for PoolDatasetInheritParentEncryptionPropertiesPost

Allows inheriting parent's encryption root discarding its current encryption settings. This
can only be done where `id` has an encrypted parent and `id` itself is an encryption root.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPoolDatasetInheritParentEncryptionPropertiesPostRequest
*/
func (a *PoolDatasetApiService) PoolDatasetInheritParentEncryptionPropertiesPost(ctx context.Context) ApiPoolDatasetInheritParentEncryptionPropertiesPostRequest {
	return ApiPoolDatasetInheritParentEncryptionPropertiesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PoolDatasetApiService) PoolDatasetInheritParentEncryptionPropertiesPostExecute(r ApiPoolDatasetInheritParentEncryptionPropertiesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetInheritParentEncryptionPropertiesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/inherit_parent_encryption_properties"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetLockPostRequest struct {
	ctx             context.Context
	ApiService      *PoolDatasetApiService
	poolDatasetLock *PoolDatasetLock
}

func (r ApiPoolDatasetLockPostRequest) PoolDatasetLock(poolDatasetLock PoolDatasetLock) ApiPoolDatasetLockPostRequest {
	r.poolDatasetLock = &poolDatasetLock
	return r
}

func (r ApiPoolDatasetLockPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.PoolDatasetLockPostExecute(r)
}

/*
PoolDatasetLockPost Method for PoolDatasetLockPost

Locks `id` dataset. It will unmount the dataset and its children before locking.

After the dataset has been unmounted, system will set immutable flag on the dataset's mountpoint where
the dataset was mounted before it was locked making sure that the path cannot be modified. Once the dataset
is unlocked, it will not be affected by this change and consumers can continue consuming it.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPoolDatasetLockPostRequest
*/
func (a *PoolDatasetApiService) PoolDatasetLockPost(ctx context.Context) ApiPoolDatasetLockPostRequest {
	return ApiPoolDatasetLockPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PoolDatasetApiService) PoolDatasetLockPostExecute(r ApiPoolDatasetLockPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetLockPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/lock"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.poolDatasetLock
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetMountpointPostRequest struct {
	ctx                   context.Context
	ApiService            *PoolDatasetApiService
	poolDatasetMountpoint *PoolDatasetMountpoint
}

func (r ApiPoolDatasetMountpointPostRequest) PoolDatasetMountpoint(poolDatasetMountpoint PoolDatasetMountpoint) ApiPoolDatasetMountpointPostRequest {
	r.poolDatasetMountpoint = &poolDatasetMountpoint
	return r
}

func (r ApiPoolDatasetMountpointPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.PoolDatasetMountpointPostExecute(r)
}

/*
PoolDatasetMountpointPost Method for PoolDatasetMountpointPost

Returns mountpoint for specific mounted dataset. If it is not mounted and `raise` is `true` (default), an
error is raised. `null` is returned otherwise.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPoolDatasetMountpointPostRequest
*/
func (a *PoolDatasetApiService) PoolDatasetMountpointPost(ctx context.Context) ApiPoolDatasetMountpointPostRequest {
	return ApiPoolDatasetMountpointPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PoolDatasetApiService) PoolDatasetMountpointPostExecute(r ApiPoolDatasetMountpointPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetMountpointPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/mountpoint"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.poolDatasetMountpoint
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetPostRequest struct {
	ctx                context.Context
	ApiService         *PoolDatasetApiService
	poolDatasetCreate0 *PoolDatasetCreate0
}

func (r ApiPoolDatasetPostRequest) PoolDatasetCreate0(poolDatasetCreate0 PoolDatasetCreate0) ApiPoolDatasetPostRequest {
	r.poolDatasetCreate0 = &poolDatasetCreate0
	return r
}

func (r ApiPoolDatasetPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.PoolDatasetPostExecute(r)
}

/*
PoolDatasetPost Method for PoolDatasetPost

Creates a dataset/zvol.

`volsize` is required for type=VOLUME and is supposed to be a multiple of the block size.
`sparse` and `volblocksize` are only used for type=VOLUME.

`encryption` when enabled will create an ZFS encrypted root dataset for `name` pool.
There are 2 cases where ZFS encryption is not allowed for a dataset:
 1. Pool in question is GELI encrypted.
 2. If the parent dataset is encrypted with a passphrase and `name` is being created
    with a key for encrypting the dataset.

`encryption_options` specifies configuration for encryption of dataset for `name` pool.
`encryption_options.passphrase` must be specified if encryption for dataset is desired with a passphrase
as a key.
Otherwise a hex encoded key can be specified by providing `encryption_options.key`.
`encryption_options.generate_key` when enabled automatically generates the key to be used
for dataset encryption.

It should be noted that keys are stored by the system for automatic locking/unlocking
on import/export of encrypted datasets. If that is not desired, dataset should be created
with a passphrase as a key.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPoolDatasetPostRequest
*/
func (a *PoolDatasetApiService) PoolDatasetPost(ctx context.Context) ApiPoolDatasetPostRequest {
	return ApiPoolDatasetPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PoolDatasetApiService) PoolDatasetPostExecute(r ApiPoolDatasetPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.poolDatasetCreate0
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetRecommendedZvolBlocksizePostRequest struct {
	ctx        context.Context
	ApiService *PoolDatasetApiService
	body       *string
}

func (r ApiPoolDatasetRecommendedZvolBlocksizePostRequest) Body(body string) ApiPoolDatasetRecommendedZvolBlocksizePostRequest {
	r.body = &body
	return r
}

func (r ApiPoolDatasetRecommendedZvolBlocksizePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.PoolDatasetRecommendedZvolBlocksizePostExecute(r)
}

/*
PoolDatasetRecommendedZvolBlocksizePost Method for PoolDatasetRecommendedZvolBlocksizePost

Helper method to get recommended size for a new zvol (dataset of type VOLUME).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPoolDatasetRecommendedZvolBlocksizePostRequest
*/
func (a *PoolDatasetApiService) PoolDatasetRecommendedZvolBlocksizePost(ctx context.Context) ApiPoolDatasetRecommendedZvolBlocksizePostRequest {
	return ApiPoolDatasetRecommendedZvolBlocksizePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PoolDatasetApiService) PoolDatasetRecommendedZvolBlocksizePostExecute(r ApiPoolDatasetRecommendedZvolBlocksizePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetRecommendedZvolBlocksizePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/recommended_zvol_blocksize"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetRecordsizeChoicesGetRequest struct {
	ctx        context.Context
	ApiService *PoolDatasetApiService
}

func (r ApiPoolDatasetRecordsizeChoicesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.PoolDatasetRecordsizeChoicesGetExecute(r)
}

/*
PoolDatasetRecordsizeChoicesGet Method for PoolDatasetRecordsizeChoicesGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPoolDatasetRecordsizeChoicesGetRequest
*/
func (a *PoolDatasetApiService) PoolDatasetRecordsizeChoicesGet(ctx context.Context) ApiPoolDatasetRecordsizeChoicesGetRequest {
	return ApiPoolDatasetRecordsizeChoicesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PoolDatasetApiService) PoolDatasetRecordsizeChoicesGetExecute(r ApiPoolDatasetRecordsizeChoicesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetRecordsizeChoicesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/recordsize_choices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetSnapshotCountPostRequest struct {
	ctx        context.Context
	ApiService *PoolDatasetApiService
	body       *string
}

func (r ApiPoolDatasetSnapshotCountPostRequest) Body(body string) ApiPoolDatasetSnapshotCountPostRequest {
	r.body = &body
	return r
}

func (r ApiPoolDatasetSnapshotCountPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.PoolDatasetSnapshotCountPostExecute(r)
}

/*
PoolDatasetSnapshotCountPost Method for PoolDatasetSnapshotCountPost

Returns snapshot count for specified `dataset`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPoolDatasetSnapshotCountPostRequest
*/
func (a *PoolDatasetApiService) PoolDatasetSnapshotCountPost(ctx context.Context) ApiPoolDatasetSnapshotCountPostRequest {
	return ApiPoolDatasetSnapshotCountPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PoolDatasetApiService) PoolDatasetSnapshotCountPostExecute(r ApiPoolDatasetSnapshotCountPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetSnapshotCountPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/snapshot_count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetUnlockPostRequest struct {
	ctx               context.Context
	ApiService        *PoolDatasetApiService
	poolDatasetUnlock *PoolDatasetUnlock
}

func (r ApiPoolDatasetUnlockPostRequest) PoolDatasetUnlock(poolDatasetUnlock PoolDatasetUnlock) ApiPoolDatasetUnlockPostRequest {
	r.poolDatasetUnlock = &poolDatasetUnlock
	return r
}

func (r ApiPoolDatasetUnlockPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.PoolDatasetUnlockPostExecute(r)
}

/*
PoolDatasetUnlockPost Method for PoolDatasetUnlockPost

Unlock dataset `id` (and its children if `unlock_options.recursive` is `true`).

If `id` dataset is not encrypted an exception will be raised. There is one exception:
when `id` is a root dataset and `unlock_options.recursive` is specified, encryption
validation will not be performed for `id`. This allow unlocking encrypted children for the entire pool `id`.

There are two ways to supply the key(s)/passphrase(s) for unlocking a dataset:

1. Upload a json file which contains encrypted dataset keys (it will be read from the input pipe if
`unlock_options.key_file` is `true`). The format is the one that is used for exporting encrypted dataset keys
(`pool.export_keys`).

2. Specify a key or a passphrase for each unlocked dataset using `unlock_options.datasets`.

If `unlock_options.datasets.{i}.recursive` is `true`, a key or a passphrase is applied to all the encrypted
children of a dataset.

`unlock_options.toggle_attachments` controls whether attachments  should be put in action after unlocking
dataset(s). Toggling attachments can theoretically lead to service interruption when daemons configurations are
reloaded (this should not happen,  and if this happens it should be considered a bug). As TrueNAS does not have
a state for resources that should be unlocked but are still locked, disabling this option will put the system
into an inconsistent state so it should really never be disabled.

In some cases it's possible that the provided key/passphrase is valid but the path where the dataset is
supposed to be mounted after being unlocked already exists and is not empty. In this case, unlock operation
would fail. This can be overridden by setting `unlock_options.datasets.X.force` boolean flag or by setting
`unlock_options.force` flag. When any of these flags are set, system will rename the existing
directory/file path where the dataset should be mounted resulting in successful unlock of the dataset.

A file might be uploaded to this endpoint. To upload a file, please send a multipart request with two parts. The first, named `data`, should contain a JSON-encoded payload, and the second, named `file`, should contain an uploaded file.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPoolDatasetUnlockPostRequest
*/
func (a *PoolDatasetApiService) PoolDatasetUnlockPost(ctx context.Context) ApiPoolDatasetUnlockPostRequest {
	return ApiPoolDatasetUnlockPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PoolDatasetApiService) PoolDatasetUnlockPostExecute(r ApiPoolDatasetUnlockPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetUnlockPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/unlock"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.poolDatasetUnlock
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetUnlockServicesRestartChoicesPostRequest struct {
	ctx        context.Context
	ApiService *PoolDatasetApiService
	body       *string
}

func (r ApiPoolDatasetUnlockServicesRestartChoicesPostRequest) Body(body string) ApiPoolDatasetUnlockServicesRestartChoicesPostRequest {
	r.body = &body
	return r
}

func (r ApiPoolDatasetUnlockServicesRestartChoicesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.PoolDatasetUnlockServicesRestartChoicesPostExecute(r)
}

/*
PoolDatasetUnlockServicesRestartChoicesPost Method for PoolDatasetUnlockServicesRestartChoicesPost

Get a mapping of services identifiers and labels that can be restart on dataset unlock.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPoolDatasetUnlockServicesRestartChoicesPostRequest
*/
func (a *PoolDatasetApiService) PoolDatasetUnlockServicesRestartChoicesPost(ctx context.Context) ApiPoolDatasetUnlockServicesRestartChoicesPostRequest {
	return ApiPoolDatasetUnlockServicesRestartChoicesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PoolDatasetApiService) PoolDatasetUnlockServicesRestartChoicesPostExecute(r ApiPoolDatasetUnlockServicesRestartChoicesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetUnlockServicesRestartChoicesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/unlock_services_restart_choices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
