/*
TrueNAS RESTful API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package bluefin

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)

// CtdbGeneralApiService CtdbGeneralApi service
type CtdbGeneralApiService service

type ApiCtdbGeneralHealthyGetRequest struct {
	ctx        context.Context
	ApiService *CtdbGeneralApiService
}

func (r ApiCtdbGeneralHealthyGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.CtdbGeneralHealthyGetExecute(r)
}

/*
CtdbGeneralHealthyGet Method for CtdbGeneralHealthyGet

Returns a boolean if the ctdb cluster is healthy.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCtdbGeneralHealthyGetRequest
*/
func (a *CtdbGeneralApiService) CtdbGeneralHealthyGet(ctx context.Context) ApiCtdbGeneralHealthyGetRequest {
	return ApiCtdbGeneralHealthyGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *CtdbGeneralApiService) CtdbGeneralHealthyGetExecute(r ApiCtdbGeneralHealthyGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CtdbGeneralApiService.CtdbGeneralHealthyGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ctdb/general/healthy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCtdbGeneralIpsPostRequest struct {
	ctx             context.Context
	ApiService      *CtdbGeneralApiService
	ctdbGeneralIps0 *CtdbGeneralIps0
}

func (r ApiCtdbGeneralIpsPostRequest) CtdbGeneralIps0(ctdbGeneralIps0 CtdbGeneralIps0) ApiCtdbGeneralIpsPostRequest {
	r.ctdbGeneralIps0 = &ctdbGeneralIps0
	return r
}

func (r ApiCtdbGeneralIpsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CtdbGeneralIpsPostExecute(r)
}

/*
CtdbGeneralIpsPost Method for CtdbGeneralIpsPost

Return a list of public ip addresses in the ctdb cluster.

Public IPs will float between nodes in the cluster and
should automatically rebalance as nodes become available.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCtdbGeneralIpsPostRequest
*/
func (a *CtdbGeneralApiService) CtdbGeneralIpsPost(ctx context.Context) ApiCtdbGeneralIpsPostRequest {
	return ApiCtdbGeneralIpsPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *CtdbGeneralApiService) CtdbGeneralIpsPostExecute(r ApiCtdbGeneralIpsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CtdbGeneralApiService.CtdbGeneralIpsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ctdb/general/ips"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ctdbGeneralIps0
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCtdbGeneralListnodesGetRequest struct {
	ctx        context.Context
	ApiService *CtdbGeneralApiService
}

func (r ApiCtdbGeneralListnodesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.CtdbGeneralListnodesGetExecute(r)
}

/*
CtdbGeneralListnodesGet Method for CtdbGeneralListnodesGet

Return a list of nodes in the ctdb cluster.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCtdbGeneralListnodesGetRequest
*/
func (a *CtdbGeneralApiService) CtdbGeneralListnodesGet(ctx context.Context) ApiCtdbGeneralListnodesGetRequest {
	return ApiCtdbGeneralListnodesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *CtdbGeneralApiService) CtdbGeneralListnodesGetExecute(r ApiCtdbGeneralListnodesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CtdbGeneralApiService.CtdbGeneralListnodesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ctdb/general/listnodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCtdbGeneralPnnGetRequest struct {
	ctx        context.Context
	ApiService *CtdbGeneralApiService
}

func (r ApiCtdbGeneralPnnGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.CtdbGeneralPnnGetExecute(r)
}

/*
CtdbGeneralPnnGet Method for CtdbGeneralPnnGet

Return node number for this node.
This value should be static for life of cluster.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCtdbGeneralPnnGetRequest
*/
func (a *CtdbGeneralApiService) CtdbGeneralPnnGet(ctx context.Context) ApiCtdbGeneralPnnGetRequest {
	return ApiCtdbGeneralPnnGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *CtdbGeneralApiService) CtdbGeneralPnnGetExecute(r ApiCtdbGeneralPnnGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CtdbGeneralApiService.CtdbGeneralPnnGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ctdb/general/pnn"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCtdbGeneralRecoveryMasterGetRequest struct {
	ctx        context.Context
	ApiService *CtdbGeneralApiService
}

func (r ApiCtdbGeneralRecoveryMasterGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.CtdbGeneralRecoveryMasterGetExecute(r)
}

/*
CtdbGeneralRecoveryMasterGet Method for CtdbGeneralRecoveryMasterGet

Return node number for the recovery master for the cluster.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCtdbGeneralRecoveryMasterGetRequest
*/
func (a *CtdbGeneralApiService) CtdbGeneralRecoveryMasterGet(ctx context.Context) ApiCtdbGeneralRecoveryMasterGetRequest {
	return ApiCtdbGeneralRecoveryMasterGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *CtdbGeneralApiService) CtdbGeneralRecoveryMasterGetExecute(r ApiCtdbGeneralRecoveryMasterGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CtdbGeneralApiService.CtdbGeneralRecoveryMasterGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ctdb/general/recovery_master"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCtdbGeneralStatusPostRequest struct {
	ctx                context.Context
	ApiService         *CtdbGeneralApiService
	ctdbGeneralStatus0 *CtdbGeneralStatus0
}

func (r ApiCtdbGeneralStatusPostRequest) CtdbGeneralStatus0(ctdbGeneralStatus0 CtdbGeneralStatus0) ApiCtdbGeneralStatusPostRequest {
	r.ctdbGeneralStatus0 = &ctdbGeneralStatus0
	return r
}

func (r ApiCtdbGeneralStatusPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CtdbGeneralStatusPostExecute(r)
}

/*
CtdbGeneralStatusPost Method for CtdbGeneralStatusPost

List the status of the ctdb cluster.

`all_nodes`: Boolean if True, return status

	for all nodes in the cluster else return
	status of this node.

`nodemap` contains the current nodemap in-memory for ctdb daemon on
this particular cluster node.

`vnnmap` list of all nodes in the cluster that are participating in
hosting the cluster databases. BANNED nodes are excluded from vnnmap.

`recovery_master` the node number of the cluster node that currently
holds the cluster recovery lock in the ctdb shared volume. This node
is responsible for performing full cluster checks and cluster node
consistency. It is also responsible for performing databse recovery
procedures. Database recovery related logs will be primarily located
on this node and so troubleshooting cluster health and recovery
operations should start here.

`recovery_mode_str` will be either 'NORMAL' or 'RECOVERY' depending
on whether database recovery is in progress in the cluster.

`recovery_mode_raw` provides raw the internal raw recovery_state of
ctdbd. Currently defined values are:
CTDB_RECOVERY_NORMAL 0
CTDB_RECOVERY_ACTIVE 1

`all_healthy` provides a summary of whether all nodes in internal
nodelist are healthy. This is a convenience feature and not an
explicit ctdb client response.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCtdbGeneralStatusPostRequest
*/
func (a *CtdbGeneralApiService) CtdbGeneralStatusPost(ctx context.Context) ApiCtdbGeneralStatusPostRequest {
	return ApiCtdbGeneralStatusPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *CtdbGeneralApiService) CtdbGeneralStatusPostExecute(r ApiCtdbGeneralStatusPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CtdbGeneralApiService.CtdbGeneralStatusPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ctdb/general/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ctdbGeneralStatus0
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
