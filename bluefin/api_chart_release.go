/*
TrueNAS RESTful API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package bluefin

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// ChartReleaseApiService ChartReleaseApi service
type ChartReleaseApiService service

type ApiChartReleaseCertificateAuthorityChoicesGetRequest struct {
	ctx        context.Context
	ApiService *ChartReleaseApiService
}

func (r ApiChartReleaseCertificateAuthorityChoicesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseCertificateAuthorityChoicesGetExecute(r)
}

/*
ChartReleaseCertificateAuthorityChoicesGet Method for ChartReleaseCertificateAuthorityChoicesGet

Returns certificate authorities which can be used by applications.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiChartReleaseCertificateAuthorityChoicesGetRequest
*/
func (a *ChartReleaseApiService) ChartReleaseCertificateAuthorityChoicesGet(ctx context.Context) ApiChartReleaseCertificateAuthorityChoicesGetRequest {
	return ApiChartReleaseCertificateAuthorityChoicesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseCertificateAuthorityChoicesGetExecute(r ApiChartReleaseCertificateAuthorityChoicesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseCertificateAuthorityChoicesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/certificate_authority_choices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChartReleaseCertificateChoicesGetRequest struct {
	ctx        context.Context
	ApiService *ChartReleaseApiService
}

func (r ApiChartReleaseCertificateChoicesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseCertificateChoicesGetExecute(r)
}

/*
ChartReleaseCertificateChoicesGet Method for ChartReleaseCertificateChoicesGet

Returns certificates which can be used by applications.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiChartReleaseCertificateChoicesGetRequest
*/
func (a *ChartReleaseApiService) ChartReleaseCertificateChoicesGet(ctx context.Context) ApiChartReleaseCertificateChoicesGetRequest {
	return ApiChartReleaseCertificateChoicesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseCertificateChoicesGetExecute(r ApiChartReleaseCertificateChoicesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseCertificateChoicesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/certificate_choices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChartReleaseEventsPostRequest struct {
	ctx        context.Context
	ApiService *ChartReleaseApiService
	body       *string
}

func (r ApiChartReleaseEventsPostRequest) Body(body string) ApiChartReleaseEventsPostRequest {
	r.body = &body
	return r
}

func (r ApiChartReleaseEventsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseEventsPostExecute(r)
}

/*
ChartReleaseEventsPost Method for ChartReleaseEventsPost

Returns kubernetes events for `release_name` Chart Release.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiChartReleaseEventsPostRequest
*/
func (a *ChartReleaseApiService) ChartReleaseEventsPost(ctx context.Context) ApiChartReleaseEventsPostRequest {
	return ApiChartReleaseEventsPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseEventsPostExecute(r ApiChartReleaseEventsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseEventsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChartReleaseGetRequest struct {
	ctx        context.Context
	ApiService *ChartReleaseApiService
	limit      *int32
	offset     *int32
	count      *bool
	sort       *string
}

func (r ApiChartReleaseGetRequest) Limit(limit int32) ApiChartReleaseGetRequest {
	r.limit = &limit
	return r
}

func (r ApiChartReleaseGetRequest) Offset(offset int32) ApiChartReleaseGetRequest {
	r.offset = &offset
	return r
}

func (r ApiChartReleaseGetRequest) Count(count bool) ApiChartReleaseGetRequest {
	r.count = &count
	return r
}

func (r ApiChartReleaseGetRequest) Sort(sort string) ApiChartReleaseGetRequest {
	r.sort = &sort
	return r
}

func (r ApiChartReleaseGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseGetExecute(r)
}

/*
ChartReleaseGet Method for ChartReleaseGet

Query available chart releases.

`query-options.extra.retrieve_resources` is a boolean when set will retrieve existing kubernetes resources
in the chart namespace.

`query-options.extra.history` is a boolean when set will retrieve all chart version upgrades
for a chart release.

`query-options.extra.include_chart_schema` is a boolean when set will retrieve the schema being used by
the chart release in question.

`query-options.extra.resource_events` is a boolean when set will retrieve individual events of each resource.
This only has effect if `query-options.extra.retrieve_resources` is set.

`query-options.extra` can be specified as query parameters with prefixing them with `extra.` prefix. For example, `extra.retrieve_properties=false` will pass `retrieve_properties` as an extra argument to pool/dataset endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiChartReleaseGetRequest
*/
func (a *ChartReleaseApiService) ChartReleaseGet(ctx context.Context) ApiChartReleaseGetRequest {
	return ApiChartReleaseGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseGetExecute(r ApiChartReleaseGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChartReleaseGetChartReleasesUsingChartReleaseImagesPostRequest struct {
	ctx        context.Context
	ApiService *ChartReleaseApiService
	body       *string
}

func (r ApiChartReleaseGetChartReleasesUsingChartReleaseImagesPostRequest) Body(body string) ApiChartReleaseGetChartReleasesUsingChartReleaseImagesPostRequest {
	r.body = &body
	return r
}

func (r ApiChartReleaseGetChartReleasesUsingChartReleaseImagesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseGetChartReleasesUsingChartReleaseImagesPostExecute(r)
}

/*
ChartReleaseGetChartReleasesUsingChartReleaseImagesPost Method for ChartReleaseGetChartReleasesUsingChartReleaseImagesPost

Retrieve chart releases which are consuming any images in use by `chart_release_name`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiChartReleaseGetChartReleasesUsingChartReleaseImagesPostRequest
*/
func (a *ChartReleaseApiService) ChartReleaseGetChartReleasesUsingChartReleaseImagesPost(ctx context.Context) ApiChartReleaseGetChartReleasesUsingChartReleaseImagesPostRequest {
	return ApiChartReleaseGetChartReleasesUsingChartReleaseImagesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseGetChartReleasesUsingChartReleaseImagesPostExecute(r ApiChartReleaseGetChartReleasesUsingChartReleaseImagesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseGetChartReleasesUsingChartReleaseImagesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/get_chart_releases_using_chart_release_images"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChartReleaseGetInstancePostRequest struct {
	ctx                     context.Context
	ApiService              *ChartReleaseApiService
	chartReleaseGetInstance *ChartReleaseGetInstance
}

func (r ApiChartReleaseGetInstancePostRequest) ChartReleaseGetInstance(chartReleaseGetInstance ChartReleaseGetInstance) ApiChartReleaseGetInstancePostRequest {
	r.chartReleaseGetInstance = &chartReleaseGetInstance
	return r
}

func (r ApiChartReleaseGetInstancePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseGetInstancePostExecute(r)
}

/*
ChartReleaseGetInstancePost Method for ChartReleaseGetInstancePost

Returns instance matching `id`. If `id` is not found, Validation error is raised.

Please see `query` method documentation for `options`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiChartReleaseGetInstancePostRequest
*/
func (a *ChartReleaseApiService) ChartReleaseGetInstancePost(ctx context.Context) ApiChartReleaseGetInstancePostRequest {
	return ApiChartReleaseGetInstancePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseGetInstancePostExecute(r ApiChartReleaseGetInstancePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseGetInstancePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/get_instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.chartReleaseGetInstance
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChartReleaseIdIdDeleteRequest struct {
	ctx        context.Context
	ApiService *ChartReleaseApiService
	id         string
}

func (r ApiChartReleaseIdIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseIdIdDeleteExecute(r)
}

/*
ChartReleaseIdIdDelete Method for ChartReleaseIdIdDelete

Delete existing chart release.

This will delete the chart release from the kubernetes cluster and also remove any associated volumes / data.
To clarify, host path volumes will not be deleted which live outside the chart release dataset.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiChartReleaseIdIdDeleteRequest
*/
func (a *ChartReleaseApiService) ChartReleaseIdIdDelete(ctx context.Context, id string) ApiChartReleaseIdIdDeleteRequest {
	return ApiChartReleaseIdIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseIdIdDeleteExecute(r ApiChartReleaseIdIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseIdIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChartReleaseIdIdGetRequest struct {
	ctx        context.Context
	ApiService *ChartReleaseApiService
	id         string
}

func (r ApiChartReleaseIdIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseIdIdGetExecute(r)
}

/*
ChartReleaseIdIdGet Method for ChartReleaseIdIdGet

Query available chart releases.

`query-options.extra.retrieve_resources` is a boolean when set will retrieve existing kubernetes resources
in the chart namespace.

`query-options.extra.history` is a boolean when set will retrieve all chart version upgrades
for a chart release.

`query-options.extra.include_chart_schema` is a boolean when set will retrieve the schema being used by
the chart release in question.

`query-options.extra.resource_events` is a boolean when set will retrieve individual events of each resource.
This only has effect if `query-options.extra.retrieve_resources` is set.

`query-options.extra` can be specified as query parameters with prefixing them with `extra.` prefix. For example, `extra.retrieve_properties=false` will pass `retrieve_properties` as an extra argument to pool/dataset endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiChartReleaseIdIdGetRequest
*/
func (a *ChartReleaseApiService) ChartReleaseIdIdGet(ctx context.Context, id string) ApiChartReleaseIdIdGetRequest {
	return ApiChartReleaseIdIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseIdIdGetExecute(r ApiChartReleaseIdIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseIdIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChartReleaseIdIdPutRequest struct {
	ctx        context.Context
	ApiService *ChartReleaseApiService
	id         string
}

func (r ApiChartReleaseIdIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseIdIdPutExecute(r)
}

/*
ChartReleaseIdIdPut Method for ChartReleaseIdIdPut

Update an existing chart release.

`values` is configuration specified for the catalog item version in question which will be used to
create the chart release.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiChartReleaseIdIdPutRequest
*/
func (a *ChartReleaseApiService) ChartReleaseIdIdPut(ctx context.Context, id string) ApiChartReleaseIdIdPutRequest {
	return ApiChartReleaseIdIdPutRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseIdIdPutExecute(r ApiChartReleaseIdIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseIdIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChartReleaseNicChoicesGetRequest struct {
	ctx        context.Context
	ApiService *ChartReleaseApiService
}

func (r ApiChartReleaseNicChoicesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseNicChoicesGetExecute(r)
}

/*
ChartReleaseNicChoicesGet Method for ChartReleaseNicChoicesGet

Available choices for NIC which can be added to a pod in a chart release.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiChartReleaseNicChoicesGetRequest
*/
func (a *ChartReleaseApiService) ChartReleaseNicChoicesGet(ctx context.Context) ApiChartReleaseNicChoicesGetRequest {
	return ApiChartReleaseNicChoicesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseNicChoicesGetExecute(r ApiChartReleaseNicChoicesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseNicChoicesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/nic_choices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChartReleasePodConsoleChoicesPostRequest struct {
	ctx        context.Context
	ApiService *ChartReleaseApiService
	body       *string
}

func (r ApiChartReleasePodConsoleChoicesPostRequest) Body(body string) ApiChartReleasePodConsoleChoicesPostRequest {
	r.body = &body
	return r
}

func (r ApiChartReleasePodConsoleChoicesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleasePodConsoleChoicesPostExecute(r)
}

/*
ChartReleasePodConsoleChoicesPost Method for ChartReleasePodConsoleChoicesPost

Returns choices for console access to a chart release.

Output is a dictionary with names of pods as keys and containing names of containers which the pod
comprises of.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiChartReleasePodConsoleChoicesPostRequest
*/
func (a *ChartReleaseApiService) ChartReleasePodConsoleChoicesPost(ctx context.Context) ApiChartReleasePodConsoleChoicesPostRequest {
	return ApiChartReleasePodConsoleChoicesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleasePodConsoleChoicesPostExecute(r ApiChartReleasePodConsoleChoicesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleasePodConsoleChoicesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/pod_console_choices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChartReleasePodLogsChoicesPostRequest struct {
	ctx        context.Context
	ApiService *ChartReleaseApiService
	body       *string
}

func (r ApiChartReleasePodLogsChoicesPostRequest) Body(body string) ApiChartReleasePodLogsChoicesPostRequest {
	r.body = &body
	return r
}

func (r ApiChartReleasePodLogsChoicesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleasePodLogsChoicesPostExecute(r)
}

/*
ChartReleasePodLogsChoicesPost Method for ChartReleasePodLogsChoicesPost

Returns choices for accessing logs of any container in any pod in a chart release.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiChartReleasePodLogsChoicesPostRequest
*/
func (a *ChartReleaseApiService) ChartReleasePodLogsChoicesPost(ctx context.Context) ApiChartReleasePodLogsChoicesPostRequest {
	return ApiChartReleasePodLogsChoicesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleasePodLogsChoicesPostExecute(r ApiChartReleasePodLogsChoicesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleasePodLogsChoicesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/pod_logs_choices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChartReleasePodLogsPostRequest struct {
	ctx                 context.Context
	ApiService          *ChartReleaseApiService
	chartReleasePodLogs *ChartReleasePodLogs
}

func (r ApiChartReleasePodLogsPostRequest) ChartReleasePodLogs(chartReleasePodLogs ChartReleasePodLogs) ApiChartReleasePodLogsPostRequest {
	r.chartReleasePodLogs = &chartReleasePodLogs
	return r
}

func (r ApiChartReleasePodLogsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleasePodLogsPostExecute(r)
}

/*
ChartReleasePodLogsPost Method for ChartReleasePodLogsPost

Export logs of `options.container_name` container in `options.pod_name` pod in `release_name` chart release.

`options.tail_lines` is an option to select how many lines of logs to retrieve for the said container. It
defaults to 500. If set to `null`, it will retrieve complete logs of the container.

`options.limit_bytes` is an option to select how many bytes to retrieve from the tail lines selected. If set
to null ( which is the default ), it will not limit the bytes returned. To clarify, `options.tail_lines`
is applied first and the required number of lines are retrieved and then `options.limit_bytes` is applied.

Please refer to websocket documentation for downloading the file.

A file will be downloaded from this endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiChartReleasePodLogsPostRequest
*/
func (a *ChartReleaseApiService) ChartReleasePodLogsPost(ctx context.Context) ApiChartReleasePodLogsPostRequest {
	return ApiChartReleasePodLogsPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleasePodLogsPostExecute(r ApiChartReleasePodLogsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleasePodLogsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/pod_logs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.chartReleasePodLogs
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChartReleasePodStatusPostRequest struct {
	ctx        context.Context
	ApiService *ChartReleaseApiService
	body       *string
}

func (r ApiChartReleasePodStatusPostRequest) Body(body string) ApiChartReleasePodStatusPostRequest {
	r.body = &body
	return r
}

func (r ApiChartReleasePodStatusPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleasePodStatusPostExecute(r)
}

/*
ChartReleasePodStatusPost Method for ChartReleasePodStatusPost

Retrieve available/desired pods status for a chart release and it's current state.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiChartReleasePodStatusPostRequest
*/
func (a *ChartReleaseApiService) ChartReleasePodStatusPost(ctx context.Context) ApiChartReleasePodStatusPostRequest {
	return ApiChartReleasePodStatusPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleasePodStatusPostExecute(r ApiChartReleasePodStatusPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleasePodStatusPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/pod_status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChartReleasePostRequest struct {
	ctx                 context.Context
	ApiService          *ChartReleaseApiService
	chartReleaseCreate0 *ChartReleaseCreate0
}

func (r ApiChartReleasePostRequest) ChartReleaseCreate0(chartReleaseCreate0 ChartReleaseCreate0) ApiChartReleasePostRequest {
	r.chartReleaseCreate0 = &chartReleaseCreate0
	return r
}

func (r ApiChartReleasePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleasePostExecute(r)
}

/*
ChartReleasePost Method for ChartReleasePost

Create a chart release for a catalog item.

`release_name` is the name which will be used to identify the created chart release.

`catalog` is a valid catalog id where system will look for catalog `item` details.

`train` is which train to look for under `catalog` i.e stable / testing etc.

`version` specifies the catalog `item` version.

`values` is configuration specified for the catalog item version in question which will be used to
create the chart release.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiChartReleasePostRequest
*/
func (a *ChartReleaseApiService) ChartReleasePost(ctx context.Context) ApiChartReleasePostRequest {
	return ApiChartReleasePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleasePostExecute(r ApiChartReleasePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleasePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.chartReleaseCreate0
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChartReleasePullContainerImagesPostRequest struct {
	ctx                             context.Context
	ApiService                      *ChartReleaseApiService
	chartReleasePullContainerImages *ChartReleasePullContainerImages
}

func (r ApiChartReleasePullContainerImagesPostRequest) ChartReleasePullContainerImages(chartReleasePullContainerImages ChartReleasePullContainerImages) ApiChartReleasePullContainerImagesPostRequest {
	r.chartReleasePullContainerImages = &chartReleasePullContainerImages
	return r
}

func (r ApiChartReleasePullContainerImagesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleasePullContainerImagesPostExecute(r)
}

/*
ChartReleasePullContainerImagesPost Method for ChartReleasePullContainerImagesPost

Update container images being used by `release_name` chart release.

`redeploy` when set will redeploy pods which will result in chart release using newer updated versions of
the container images.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiChartReleasePullContainerImagesPostRequest
*/
func (a *ChartReleaseApiService) ChartReleasePullContainerImagesPost(ctx context.Context) ApiChartReleasePullContainerImagesPostRequest {
	return ApiChartReleasePullContainerImagesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleasePullContainerImagesPostExecute(r ApiChartReleasePullContainerImagesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleasePullContainerImagesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/pull_container_images"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.chartReleasePullContainerImages
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChartReleaseRedeployPostRequest struct {
	ctx        context.Context
	ApiService *ChartReleaseApiService
	body       *string
}

func (r ApiChartReleaseRedeployPostRequest) Body(body string) ApiChartReleaseRedeployPostRequest {
	r.body = &body
	return r
}

func (r ApiChartReleaseRedeployPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseRedeployPostExecute(r)
}

/*
ChartReleaseRedeployPost Method for ChartReleaseRedeployPost

Redeploy will initiate a new rollout of the Helm chart according to upgrade strategy defined by the chart
release workloads. A good example for redeploying is updating kubernetes pods with an updated container image.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiChartReleaseRedeployPostRequest
*/
func (a *ChartReleaseApiService) ChartReleaseRedeployPost(ctx context.Context) ApiChartReleaseRedeployPostRequest {
	return ApiChartReleaseRedeployPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseRedeployPostExecute(r ApiChartReleaseRedeployPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseRedeployPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/redeploy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChartReleaseRemoveIxVolumePostRequest struct {
	ctx                        context.Context
	ApiService                 *ChartReleaseApiService
	chartReleaseRemoveIxVolume *ChartReleaseRemoveIxVolume
}

func (r ApiChartReleaseRemoveIxVolumePostRequest) ChartReleaseRemoveIxVolume(chartReleaseRemoveIxVolume ChartReleaseRemoveIxVolume) ApiChartReleaseRemoveIxVolumePostRequest {
	r.chartReleaseRemoveIxVolume = &chartReleaseRemoveIxVolume
	return r
}

func (r ApiChartReleaseRemoveIxVolumePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseRemoveIxVolumePostExecute(r)
}

/*
ChartReleaseRemoveIxVolumePost Method for ChartReleaseRemoveIxVolumePost

Remove `volume_name` ix_volume from `release_name` chart release.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiChartReleaseRemoveIxVolumePostRequest
*/
func (a *ChartReleaseApiService) ChartReleaseRemoveIxVolumePost(ctx context.Context) ApiChartReleaseRemoveIxVolumePostRequest {
	return ApiChartReleaseRemoveIxVolumePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseRemoveIxVolumePostExecute(r ApiChartReleaseRemoveIxVolumePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseRemoveIxVolumePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/remove_ix_volume"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.chartReleaseRemoveIxVolume
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChartReleaseRollbackPostRequest struct {
	ctx                  context.Context
	ApiService           *ChartReleaseApiService
	chartReleaseRollback *ChartReleaseRollback
}

func (r ApiChartReleaseRollbackPostRequest) ChartReleaseRollback(chartReleaseRollback ChartReleaseRollback) ApiChartReleaseRollbackPostRequest {
	r.chartReleaseRollback = &chartReleaseRollback
	return r
}

func (r ApiChartReleaseRollbackPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseRollbackPostExecute(r)
}

/*
ChartReleaseRollbackPost Method for ChartReleaseRollbackPost

Rollback a chart release to a previous chart version.

`item_version` is version which we want to rollback a chart release to.

`rollback_snapshot` is a boolean value which when set will rollback snapshots of any PVC's or ix volumes being
consumed by the chart release.

`force_rollback` is a boolean which when set will force rollback operation to move forward even if no
snapshots are found. This is only useful when `rollback_snapshot` is set.

`recreate_resources` is a boolean which will delete and then create the kubernetes resources on rollback
of chart release. This should be used with caution as if chart release is consuming immutable objects like
a PVC, the rollback operation can't be performed and will fail as helm tries to do a 3 way patch for rollback.

Rollback is functional for the actual configuration of the release at the `item_version` specified and
any associated `ix_volumes` with any PVC's which were consuming chart release storage class.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiChartReleaseRollbackPostRequest
*/
func (a *ChartReleaseApiService) ChartReleaseRollbackPost(ctx context.Context) ApiChartReleaseRollbackPostRequest {
	return ApiChartReleaseRollbackPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseRollbackPostExecute(r ApiChartReleaseRollbackPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseRollbackPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/rollback"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.chartReleaseRollback
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChartReleaseScalePostRequest struct {
	ctx               context.Context
	ApiService        *ChartReleaseApiService
	chartReleaseScale *ChartReleaseScale
}

func (r ApiChartReleaseScalePostRequest) ChartReleaseScale(chartReleaseScale ChartReleaseScale) ApiChartReleaseScalePostRequest {
	r.chartReleaseScale = &chartReleaseScale
	return r
}

func (r ApiChartReleaseScalePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseScalePostExecute(r)
}

/*
ChartReleaseScalePost Method for ChartReleaseScalePost

Scale a `release_name` chart release to `scale_options.replica_count` specified.

This will scale deployments/statefulset to replica count specified.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiChartReleaseScalePostRequest
*/
func (a *ChartReleaseApiService) ChartReleaseScalePost(ctx context.Context) ApiChartReleaseScalePostRequest {
	return ApiChartReleaseScalePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseScalePostExecute(r ApiChartReleaseScalePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseScalePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/scale"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.chartReleaseScale
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChartReleaseScaleWorkloadsPostRequest struct {
	ctx                        context.Context
	ApiService                 *ChartReleaseApiService
	chartReleaseScaleWorkloads *ChartReleaseScaleWorkloads
}

func (r ApiChartReleaseScaleWorkloadsPostRequest) ChartReleaseScaleWorkloads(chartReleaseScaleWorkloads ChartReleaseScaleWorkloads) ApiChartReleaseScaleWorkloadsPostRequest {
	r.chartReleaseScaleWorkloads = &chartReleaseScaleWorkloads
	return r
}

func (r ApiChartReleaseScaleWorkloadsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseScaleWorkloadsPostExecute(r)
}

/*
ChartReleaseScaleWorkloadsPost Method for ChartReleaseScaleWorkloadsPost

Scale workloads in a chart release to specified `replica_count`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiChartReleaseScaleWorkloadsPostRequest
*/
func (a *ChartReleaseApiService) ChartReleaseScaleWorkloadsPost(ctx context.Context) ApiChartReleaseScaleWorkloadsPostRequest {
	return ApiChartReleaseScaleWorkloadsPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseScaleWorkloadsPostExecute(r ApiChartReleaseScaleWorkloadsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseScaleWorkloadsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/scale_workloads"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.chartReleaseScaleWorkloads
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChartReleaseScaleableResourcesGetRequest struct {
	ctx        context.Context
	ApiService *ChartReleaseApiService
}

func (r ApiChartReleaseScaleableResourcesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseScaleableResourcesGetExecute(r)
}

/*
ChartReleaseScaleableResourcesGet Method for ChartReleaseScaleableResourcesGet

Returns choices for types of workloads which can be scaled up/down.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiChartReleaseScaleableResourcesGetRequest
*/
func (a *ChartReleaseApiService) ChartReleaseScaleableResourcesGet(ctx context.Context) ApiChartReleaseScaleableResourcesGetRequest {
	return ApiChartReleaseScaleableResourcesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseScaleableResourcesGetExecute(r ApiChartReleaseScaleableResourcesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseScaleableResourcesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/scaleable_resources"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChartReleaseUpgradePostRequest struct {
	ctx                 context.Context
	ApiService          *ChartReleaseApiService
	chartReleaseUpgrade *ChartReleaseUpgrade
}

func (r ApiChartReleaseUpgradePostRequest) ChartReleaseUpgrade(chartReleaseUpgrade ChartReleaseUpgrade) ApiChartReleaseUpgradePostRequest {
	r.chartReleaseUpgrade = &chartReleaseUpgrade
	return r
}

func (r ApiChartReleaseUpgradePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseUpgradePostExecute(r)
}

/*
ChartReleaseUpgradePost Method for ChartReleaseUpgradePost

Upgrade `release_name` chart release.

`upgrade_options.item_version` specifies to which item version chart release should be upgraded to.

System will update container images being used by `release_name` chart release as a chart release
upgrade is not considered complete until the images in use have also been updated to latest versions.

During upgrade, `upgrade_options.values` can be specified to apply configuration changes for configuration
changes for the chart release in question.

When chart version is upgraded, system will automatically take a snapshot of `ix_volumes` in question
which can be used to rollback later on.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiChartReleaseUpgradePostRequest
*/
func (a *ChartReleaseApiService) ChartReleaseUpgradePost(ctx context.Context) ApiChartReleaseUpgradePostRequest {
	return ApiChartReleaseUpgradePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseUpgradePostExecute(r ApiChartReleaseUpgradePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseUpgradePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/upgrade"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.chartReleaseUpgrade
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChartReleaseUpgradeSummaryPostRequest struct {
	ctx                        context.Context
	ApiService                 *ChartReleaseApiService
	chartReleaseUpgradeSummary *ChartReleaseUpgradeSummary
}

func (r ApiChartReleaseUpgradeSummaryPostRequest) ChartReleaseUpgradeSummary(chartReleaseUpgradeSummary ChartReleaseUpgradeSummary) ApiChartReleaseUpgradeSummaryPostRequest {
	r.chartReleaseUpgradeSummary = &chartReleaseUpgradeSummary
	return r
}

func (r ApiChartReleaseUpgradeSummaryPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseUpgradeSummaryPostExecute(r)
}

/*
ChartReleaseUpgradeSummaryPost Method for ChartReleaseUpgradeSummaryPost

Retrieve upgrade summary for `release_name` which will include which container images will be updated
and changelog for `options.item_version` chart version specified if applicable. If only container images
need to be updated, changelog will be `null`.

If chart release `release_name` does not require an upgrade, an error will be raised.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiChartReleaseUpgradeSummaryPostRequest
*/
func (a *ChartReleaseApiService) ChartReleaseUpgradeSummaryPost(ctx context.Context) ApiChartReleaseUpgradeSummaryPostRequest {
	return ApiChartReleaseUpgradeSummaryPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseUpgradeSummaryPostExecute(r ApiChartReleaseUpgradeSummaryPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseUpgradeSummaryPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/upgrade_summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.chartReleaseUpgradeSummary
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChartReleaseUsedPortsGetRequest struct {
	ctx        context.Context
	ApiService *ChartReleaseApiService
}

func (r ApiChartReleaseUsedPortsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseUsedPortsGetExecute(r)
}

/*
ChartReleaseUsedPortsGet Method for ChartReleaseUsedPortsGet

Returns ports in use by applications.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiChartReleaseUsedPortsGetRequest
*/
func (a *ChartReleaseApiService) ChartReleaseUsedPortsGet(ctx context.Context) ApiChartReleaseUsedPortsGetRequest {
	return ApiChartReleaseUsedPortsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseUsedPortsGetExecute(r ApiChartReleaseUsedPortsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseUsedPortsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/used_ports"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
