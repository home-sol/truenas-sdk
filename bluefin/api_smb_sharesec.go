/*
TrueNAS RESTful API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package bluefin

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// SmbSharesecApiService SmbSharesecApi service
type SmbSharesecApiService service

type ApiSmbSharesecGetRequest struct {
	ctx        context.Context
	ApiService *SmbSharesecApiService
	limit      *int32
	offset     *int32
	count      *bool
	sort       *string
}

func (r ApiSmbSharesecGetRequest) Limit(limit int32) ApiSmbSharesecGetRequest {
	r.limit = &limit
	return r
}

func (r ApiSmbSharesecGetRequest) Offset(offset int32) ApiSmbSharesecGetRequest {
	r.offset = &offset
	return r
}

func (r ApiSmbSharesecGetRequest) Count(count bool) ApiSmbSharesecGetRequest {
	r.count = &count
	return r
}

func (r ApiSmbSharesecGetRequest) Sort(sort string) ApiSmbSharesecGetRequest {
	r.sort = &sort
	return r
}

func (r ApiSmbSharesecGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.SmbSharesecGetExecute(r)
}

/*
SmbSharesecGet Method for SmbSharesecGet

Use query-filters to search the SMB share ACLs present on server.

`query-options.extra` can be specified as query parameters with prefixing them with `extra.` prefix. For example, `extra.retrieve_properties=false` will pass `retrieve_properties` as an extra argument to pool/dataset endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmbSharesecGetRequest
*/
func (a *SmbSharesecApiService) SmbSharesecGet(ctx context.Context) ApiSmbSharesecGetRequest {
	return ApiSmbSharesecGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *SmbSharesecApiService) SmbSharesecGetExecute(r ApiSmbSharesecGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmbSharesecApiService.SmbSharesecGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smb/sharesec"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSmbSharesecGetInstancePostRequest struct {
	ctx                    context.Context
	ApiService             *SmbSharesecApiService
	smbSharesecGetInstance *SmbSharesecGetInstance
}

func (r ApiSmbSharesecGetInstancePostRequest) SmbSharesecGetInstance(smbSharesecGetInstance SmbSharesecGetInstance) ApiSmbSharesecGetInstancePostRequest {
	r.smbSharesecGetInstance = &smbSharesecGetInstance
	return r
}

func (r ApiSmbSharesecGetInstancePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.SmbSharesecGetInstancePostExecute(r)
}

/*
SmbSharesecGetInstancePost Method for SmbSharesecGetInstancePost

Returns instance matching `id`. If `id` is not found, Validation error is raised.

Please see `query` method documentation for `options`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmbSharesecGetInstancePostRequest
*/
func (a *SmbSharesecApiService) SmbSharesecGetInstancePost(ctx context.Context) ApiSmbSharesecGetInstancePostRequest {
	return ApiSmbSharesecGetInstancePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *SmbSharesecApiService) SmbSharesecGetInstancePostExecute(r ApiSmbSharesecGetInstancePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmbSharesecApiService.SmbSharesecGetInstancePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smb/sharesec/get_instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.smbSharesecGetInstance
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSmbSharesecGetaclPostRequest struct {
	ctx               context.Context
	ApiService        *SmbSharesecApiService
	smbSharesecGetacl *SmbSharesecGetacl
}

func (r ApiSmbSharesecGetaclPostRequest) SmbSharesecGetacl(smbSharesecGetacl SmbSharesecGetacl) ApiSmbSharesecGetaclPostRequest {
	r.smbSharesecGetacl = &smbSharesecGetacl
	return r
}

func (r ApiSmbSharesecGetaclPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.SmbSharesecGetaclPostExecute(r)
}

/*
SmbSharesecGetaclPost Method for SmbSharesecGetaclPost

View the ACL information for `share_name`. The share ACL is distinct from filesystem
ACLs which can be viewed by calling `filesystem.getacl`. `ae_who_name` will appear
as `None` if the SMB service is stopped or if winbind is unable  to resolve the SID
to a name.

If the `option` `resolve_sids` is set to `False` then the returned ACL will not
contain names.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmbSharesecGetaclPostRequest
*/
func (a *SmbSharesecApiService) SmbSharesecGetaclPost(ctx context.Context) ApiSmbSharesecGetaclPostRequest {
	return ApiSmbSharesecGetaclPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *SmbSharesecApiService) SmbSharesecGetaclPostExecute(r ApiSmbSharesecGetaclPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmbSharesecApiService.SmbSharesecGetaclPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smb/sharesec/getacl"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.smbSharesecGetacl
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSmbSharesecIdIdDeleteRequest struct {
	ctx        context.Context
	ApiService *SmbSharesecApiService
	id         int32
}

func (r ApiSmbSharesecIdIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.SmbSharesecIdIdDeleteExecute(r)
}

/*
SmbSharesecIdIdDelete Method for SmbSharesecIdIdDelete

Replace share ACL for the specified SMB share with the samba default ACL of S-1-1-0/FULL
(Everyone - Full Control). In this case, access will be fully determined
by the underlying filesystem ACLs and smb4.conf parameters governing access control
and permissions.
Share can be deleted by name or numerical by numerical index.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiSmbSharesecIdIdDeleteRequest
*/
func (a *SmbSharesecApiService) SmbSharesecIdIdDelete(ctx context.Context, id int32) ApiSmbSharesecIdIdDeleteRequest {
	return ApiSmbSharesecIdIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *SmbSharesecApiService) SmbSharesecIdIdDeleteExecute(r ApiSmbSharesecIdIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmbSharesecApiService.SmbSharesecIdIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smb/sharesec/id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSmbSharesecIdIdGetRequest struct {
	ctx        context.Context
	ApiService *SmbSharesecApiService
	id         int32
}

func (r ApiSmbSharesecIdIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.SmbSharesecIdIdGetExecute(r)
}

/*
SmbSharesecIdIdGet Method for SmbSharesecIdIdGet

Use query-filters to search the SMB share ACLs present on server.

`query-options.extra` can be specified as query parameters with prefixing them with `extra.` prefix. For example, `extra.retrieve_properties=false` will pass `retrieve_properties` as an extra argument to pool/dataset endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiSmbSharesecIdIdGetRequest
*/
func (a *SmbSharesecApiService) SmbSharesecIdIdGet(ctx context.Context, id int32) ApiSmbSharesecIdIdGetRequest {
	return ApiSmbSharesecIdIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *SmbSharesecApiService) SmbSharesecIdIdGetExecute(r ApiSmbSharesecIdIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmbSharesecApiService.SmbSharesecIdIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smb/sharesec/id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSmbSharesecIdIdPutRequest struct {
	ctx        context.Context
	ApiService *SmbSharesecApiService
	id         int32
}

func (r ApiSmbSharesecIdIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.SmbSharesecIdIdPutExecute(r)
}

/*
SmbSharesecIdIdPut Method for SmbSharesecIdIdPut

Update the ACL on the share specified by the numerical index `id`. Will write changes
to both /var/db/system/samba4/share_info.tdb and the configuration file.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiSmbSharesecIdIdPutRequest
*/
func (a *SmbSharesecApiService) SmbSharesecIdIdPut(ctx context.Context, id int32) ApiSmbSharesecIdIdPutRequest {
	return ApiSmbSharesecIdIdPutRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *SmbSharesecApiService) SmbSharesecIdIdPutExecute(r ApiSmbSharesecIdIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmbSharesecApiService.SmbSharesecIdIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smb/sharesec/id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSmbSharesecPostRequest struct {
	ctx                context.Context
	ApiService         *SmbSharesecApiService
	smbSharesecCreate0 *SmbSharesecCreate0
}

func (r ApiSmbSharesecPostRequest) SmbSharesecCreate0(smbSharesecCreate0 SmbSharesecCreate0) ApiSmbSharesecPostRequest {
	r.smbSharesecCreate0 = &smbSharesecCreate0
	return r
}

func (r ApiSmbSharesecPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.SmbSharesecPostExecute(r)
}

/*
SmbSharesecPost Method for SmbSharesecPost

Update the ACL on a given SMB share. Will write changes to both
/var/db/system/samba4/share_info.tdb and the configuration file.
Since an SMB share will _always_ have an ACL present, there is little
distinction between the `create` and `update` methods apart from arguments.

`share_name` - name of SMB share.

`share_acl` a list of ACL entries (dictionaries) with the following keys:

`ae_who_sid` who the ACL entry applies to expressed as a Windows SID

`ae_who_name` who the ACL entry applies to expressed as a name. `ae_who_name` is
a dictionary containing the following keys: `domain` that the user is a member of,
`name` username in the domain. The domain for local users is the netbios name of
the FreeNAS server.

`ae_perm` string representation of the permissions granted to the user or group.
`FULL` grants read, write, execute, delete, write acl, and change owner.
`CHANGE` grants read, write, execute, and delete.
`READ` grants read and execute.

`ae_type` can be ALLOWED or DENIED.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmbSharesecPostRequest
*/
func (a *SmbSharesecApiService) SmbSharesecPost(ctx context.Context) ApiSmbSharesecPostRequest {
	return ApiSmbSharesecPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *SmbSharesecApiService) SmbSharesecPostExecute(r ApiSmbSharesecPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmbSharesecApiService.SmbSharesecPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smb/sharesec"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.smbSharesecCreate0
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSmbSharesecSynchronizeAclsGetRequest struct {
	ctx        context.Context
	ApiService *SmbSharesecApiService
}

func (r ApiSmbSharesecSynchronizeAclsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.SmbSharesecSynchronizeAclsGetExecute(r)
}

/*
SmbSharesecSynchronizeAclsGet Method for SmbSharesecSynchronizeAclsGet

Synchronize the share ACL stored in the config database with Samba's running
configuration as reflected in the share_info.tdb file.

The only situation in which the configuration stored in the database will
overwrite samba's running configuration is if share_info.tdb is empty. Samba
fakes a single S-1-1-0:ALLOW/0x0/FULL entry in the absence of an entry for a
share in share_info.tdb.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSmbSharesecSynchronizeAclsGetRequest
*/
func (a *SmbSharesecApiService) SmbSharesecSynchronizeAclsGet(ctx context.Context) ApiSmbSharesecSynchronizeAclsGetRequest {
	return ApiSmbSharesecSynchronizeAclsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *SmbSharesecApiService) SmbSharesecSynchronizeAclsGetExecute(r ApiSmbSharesecSynchronizeAclsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmbSharesecApiService.SmbSharesecSynchronizeAclsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smb/sharesec/synchronize_acls"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
