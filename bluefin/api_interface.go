/*
TrueNAS RESTful API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package bluefin

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// InterfaceApiService InterfaceApi service
type InterfaceApiService service

type ApiInterfaceBridgeMembersChoicesPostRequest struct {
	ctx        context.Context
	ApiService *InterfaceApiService
	body       *string
}

func (r ApiInterfaceBridgeMembersChoicesPostRequest) Body(body string) ApiInterfaceBridgeMembersChoicesPostRequest {
	r.body = &body
	return r
}

func (r ApiInterfaceBridgeMembersChoicesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.InterfaceBridgeMembersChoicesPostExecute(r)
}

/*
InterfaceBridgeMembersChoicesPost Method for InterfaceBridgeMembersChoicesPost

Return available interface choices that can be added to a `br` (bridge) interface.

`id` is name of existing bridge interface on the system that will have its member

	       interfaces included.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInterfaceBridgeMembersChoicesPostRequest
*/
func (a *InterfaceApiService) InterfaceBridgeMembersChoicesPost(ctx context.Context) ApiInterfaceBridgeMembersChoicesPostRequest {
	return ApiInterfaceBridgeMembersChoicesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *InterfaceApiService) InterfaceBridgeMembersChoicesPostExecute(r ApiInterfaceBridgeMembersChoicesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InterfaceApiService.InterfaceBridgeMembersChoicesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interface/bridge_members_choices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInterfaceCancelRollbackGetRequest struct {
	ctx        context.Context
	ApiService *InterfaceApiService
}

func (r ApiInterfaceCancelRollbackGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.InterfaceCancelRollbackGetExecute(r)
}

/*
InterfaceCancelRollbackGet Method for InterfaceCancelRollbackGet

If this method is called after interface changes have been committed and within the checkin timeout,
then the task that automatically rollsback any interface changes is cancelled and the in-memory snapshot
of database tables for the various interface tables will NOT be cleared.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInterfaceCancelRollbackGetRequest
*/
func (a *InterfaceApiService) InterfaceCancelRollbackGet(ctx context.Context) ApiInterfaceCancelRollbackGetRequest {
	return ApiInterfaceCancelRollbackGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *InterfaceApiService) InterfaceCancelRollbackGetExecute(r ApiInterfaceCancelRollbackGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InterfaceApiService.InterfaceCancelRollbackGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interface/cancel_rollback"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInterfaceCheckinGetRequest struct {
	ctx        context.Context
	ApiService *InterfaceApiService
}

func (r ApiInterfaceCheckinGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.InterfaceCheckinGetExecute(r)
}

/*
InterfaceCheckinGet Method for InterfaceCheckinGet

If this method is called after interface changes have been committed and within the checkin timeout,
then the task that automatically rollsback any interface changes is cancelled and the in-memory snapshot
of database tables for the various interface tables will be cleared. The idea is that the end-user has
verified the changes work as intended and need to be committed permanently.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInterfaceCheckinGetRequest
*/
func (a *InterfaceApiService) InterfaceCheckinGet(ctx context.Context) ApiInterfaceCheckinGetRequest {
	return ApiInterfaceCheckinGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *InterfaceApiService) InterfaceCheckinGetExecute(r ApiInterfaceCheckinGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InterfaceApiService.InterfaceCheckinGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interface/checkin"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInterfaceCheckinWaitingGetRequest struct {
	ctx        context.Context
	ApiService *InterfaceApiService
}

func (r ApiInterfaceCheckinWaitingGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.InterfaceCheckinWaitingGetExecute(r)
}

/*
InterfaceCheckinWaitingGet Method for InterfaceCheckinWaitingGet

Returns whether or not we are waiting user to checkin the applied network changes
before they are rolled back.
Value is in number of seconds or null.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInterfaceCheckinWaitingGetRequest
*/
func (a *InterfaceApiService) InterfaceCheckinWaitingGet(ctx context.Context) ApiInterfaceCheckinWaitingGetRequest {
	return ApiInterfaceCheckinWaitingGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *InterfaceApiService) InterfaceCheckinWaitingGetExecute(r ApiInterfaceCheckinWaitingGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InterfaceApiService.InterfaceCheckinWaitingGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interface/checkin_waiting"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInterfaceChoicesPostRequest struct {
	ctx               context.Context
	ApiService        *InterfaceApiService
	interfaceChoices0 *InterfaceChoices0
}

func (r ApiInterfaceChoicesPostRequest) InterfaceChoices0(interfaceChoices0 InterfaceChoices0) ApiInterfaceChoicesPostRequest {
	r.interfaceChoices0 = &interfaceChoices0
	return r
}

func (r ApiInterfaceChoicesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.InterfaceChoicesPostExecute(r)
}

/*
InterfaceChoicesPost Method for InterfaceChoicesPost

Choices of available network interfaces.

`bridge_members` will include BRIDGE members.
`lag_ports` will include LINK_AGGREGATION ports.
`vlan_parent` will include VLAN parent interface.
`exclude` is a list of interfaces prefix to remove.
`include` is a list of interfaces that should not be removed.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInterfaceChoicesPostRequest
*/
func (a *InterfaceApiService) InterfaceChoicesPost(ctx context.Context) ApiInterfaceChoicesPostRequest {
	return ApiInterfaceChoicesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *InterfaceApiService) InterfaceChoicesPostExecute(r ApiInterfaceChoicesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InterfaceApiService.InterfaceChoicesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interface/choices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.interfaceChoices0
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInterfaceCommitPostRequest struct {
	ctx              context.Context
	ApiService       *InterfaceApiService
	interfaceCommit0 *InterfaceCommit0
}

func (r ApiInterfaceCommitPostRequest) InterfaceCommit0(interfaceCommit0 InterfaceCommit0) ApiInterfaceCommitPostRequest {
	r.interfaceCommit0 = &interfaceCommit0
	return r
}

func (r ApiInterfaceCommitPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.InterfaceCommitPostExecute(r)
}

/*
InterfaceCommitPost Method for InterfaceCommitPost

Commit/apply pending interfaces changes.

`rollback` as true (default) will rollback changes in case they fail to apply.
`checkin_timeout` is the time in seconds it will wait for the checkin call to acknowledge
the interfaces changes happened as planned from the user. If checkin does not happen
within this period of time the changes will get reverted.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInterfaceCommitPostRequest
*/
func (a *InterfaceApiService) InterfaceCommitPost(ctx context.Context) ApiInterfaceCommitPostRequest {
	return ApiInterfaceCommitPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *InterfaceApiService) InterfaceCommitPostExecute(r ApiInterfaceCommitPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InterfaceApiService.InterfaceCommitPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interface/commit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.interfaceCommit0
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInterfaceDefaultRouteWillBeRemovedGetRequest struct {
	ctx        context.Context
	ApiService *InterfaceApiService
}

func (r ApiInterfaceDefaultRouteWillBeRemovedGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.InterfaceDefaultRouteWillBeRemovedGetExecute(r)
}

/*
InterfaceDefaultRouteWillBeRemovedGet Method for InterfaceDefaultRouteWillBeRemovedGet

On a fresh install of SCALE, dhclient is started for every interface so IP
addresses/routes could be installed via that program. However, when the
end-user goes to configure the first interface we tear down all other interfaces
configs AND delete the default route. We also remove the default route if the
configured gateway doesn't match the one currently installed in kernel.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInterfaceDefaultRouteWillBeRemovedGetRequest
*/
func (a *InterfaceApiService) InterfaceDefaultRouteWillBeRemovedGet(ctx context.Context) ApiInterfaceDefaultRouteWillBeRemovedGetRequest {
	return ApiInterfaceDefaultRouteWillBeRemovedGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *InterfaceApiService) InterfaceDefaultRouteWillBeRemovedGetExecute(r ApiInterfaceDefaultRouteWillBeRemovedGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InterfaceApiService.InterfaceDefaultRouteWillBeRemovedGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interface/default_route_will_be_removed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInterfaceGetRequest struct {
	ctx        context.Context
	ApiService *InterfaceApiService
	limit      *int32
	offset     *int32
	count      *bool
	sort       *string
}

func (r ApiInterfaceGetRequest) Limit(limit int32) ApiInterfaceGetRequest {
	r.limit = &limit
	return r
}

func (r ApiInterfaceGetRequest) Offset(offset int32) ApiInterfaceGetRequest {
	r.offset = &offset
	return r
}

func (r ApiInterfaceGetRequest) Count(count bool) ApiInterfaceGetRequest {
	r.count = &count
	return r
}

func (r ApiInterfaceGetRequest) Sort(sort string) ApiInterfaceGetRequest {
	r.sort = &sort
	return r
}

func (r ApiInterfaceGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.InterfaceGetExecute(r)
}

/*
InterfaceGet Method for InterfaceGet

Query Interfaces with `query-filters` and `query-options`

`query-options.extra` can be specified as query parameters with prefixing them with `extra.` prefix. For example, `extra.retrieve_properties=false` will pass `retrieve_properties` as an extra argument to pool/dataset endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInterfaceGetRequest
*/
func (a *InterfaceApiService) InterfaceGet(ctx context.Context) ApiInterfaceGetRequest {
	return ApiInterfaceGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *InterfaceApiService) InterfaceGetExecute(r ApiInterfaceGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InterfaceApiService.InterfaceGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interface"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInterfaceGetInstancePostRequest struct {
	ctx                  context.Context
	ApiService           *InterfaceApiService
	interfaceGetInstance *InterfaceGetInstance
}

func (r ApiInterfaceGetInstancePostRequest) InterfaceGetInstance(interfaceGetInstance InterfaceGetInstance) ApiInterfaceGetInstancePostRequest {
	r.interfaceGetInstance = &interfaceGetInstance
	return r
}

func (r ApiInterfaceGetInstancePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.InterfaceGetInstancePostExecute(r)
}

/*
InterfaceGetInstancePost Method for InterfaceGetInstancePost

Returns instance matching `id`. If `id` is not found, Validation error is raised.

Please see `query` method documentation for `options`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInterfaceGetInstancePostRequest
*/
func (a *InterfaceApiService) InterfaceGetInstancePost(ctx context.Context) ApiInterfaceGetInstancePostRequest {
	return ApiInterfaceGetInstancePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *InterfaceApiService) InterfaceGetInstancePostExecute(r ApiInterfaceGetInstancePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InterfaceApiService.InterfaceGetInstancePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interface/get_instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.interfaceGetInstance
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInterfaceHasPendingChangesGetRequest struct {
	ctx        context.Context
	ApiService *InterfaceApiService
}

func (r ApiInterfaceHasPendingChangesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.InterfaceHasPendingChangesGetExecute(r)
}

/*
InterfaceHasPendingChangesGet Method for InterfaceHasPendingChangesGet

Returns whether there are pending interfaces changes to be applied or not.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInterfaceHasPendingChangesGetRequest
*/
func (a *InterfaceApiService) InterfaceHasPendingChangesGet(ctx context.Context) ApiInterfaceHasPendingChangesGetRequest {
	return ApiInterfaceHasPendingChangesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *InterfaceApiService) InterfaceHasPendingChangesGetExecute(r ApiInterfaceHasPendingChangesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InterfaceApiService.InterfaceHasPendingChangesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interface/has_pending_changes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInterfaceIdIdDeleteRequest struct {
	ctx        context.Context
	ApiService *InterfaceApiService
	id         string
}

func (r ApiInterfaceIdIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.InterfaceIdIdDeleteExecute(r)
}

/*
InterfaceIdIdDelete Method for InterfaceIdIdDelete

Delete Interface of `id`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiInterfaceIdIdDeleteRequest
*/
func (a *InterfaceApiService) InterfaceIdIdDelete(ctx context.Context, id string) ApiInterfaceIdIdDeleteRequest {
	return ApiInterfaceIdIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *InterfaceApiService) InterfaceIdIdDeleteExecute(r ApiInterfaceIdIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InterfaceApiService.InterfaceIdIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interface/id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInterfaceIdIdGetRequest struct {
	ctx        context.Context
	ApiService *InterfaceApiService
	id         string
}

func (r ApiInterfaceIdIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.InterfaceIdIdGetExecute(r)
}

/*
InterfaceIdIdGet Method for InterfaceIdIdGet

Query Interfaces with `query-filters` and `query-options`

`query-options.extra` can be specified as query parameters with prefixing them with `extra.` prefix. For example, `extra.retrieve_properties=false` will pass `retrieve_properties` as an extra argument to pool/dataset endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiInterfaceIdIdGetRequest
*/
func (a *InterfaceApiService) InterfaceIdIdGet(ctx context.Context, id string) ApiInterfaceIdIdGetRequest {
	return ApiInterfaceIdIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *InterfaceApiService) InterfaceIdIdGetExecute(r ApiInterfaceIdIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InterfaceApiService.InterfaceIdIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interface/id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInterfaceIdIdPutRequest struct {
	ctx        context.Context
	ApiService *InterfaceApiService
	id         string
}

func (r ApiInterfaceIdIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.InterfaceIdIdPutExecute(r)
}

/*
InterfaceIdIdPut Method for InterfaceIdIdPut

Update Interface of `id`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiInterfaceIdIdPutRequest
*/
func (a *InterfaceApiService) InterfaceIdIdPut(ctx context.Context, id string) ApiInterfaceIdIdPutRequest {
	return ApiInterfaceIdIdPutRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *InterfaceApiService) InterfaceIdIdPutExecute(r ApiInterfaceIdIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InterfaceApiService.InterfaceIdIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interface/id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInterfaceIpInUsePostRequest struct {
	ctx               context.Context
	ApiService        *InterfaceApiService
	interfaceIpInUse0 *InterfaceIpInUse0
}

func (r ApiInterfaceIpInUsePostRequest) InterfaceIpInUse0(interfaceIpInUse0 InterfaceIpInUse0) ApiInterfaceIpInUsePostRequest {
	r.interfaceIpInUse0 = &interfaceIpInUse0
	return r
}

func (r ApiInterfaceIpInUsePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.InterfaceIpInUsePostExecute(r)
}

/*
InterfaceIpInUsePost Method for InterfaceIpInUsePost

Get all IPv4 / Ipv6 from all valid interfaces, excluding tap and epair.

`loopback` will return loopback interface addresses.

`any` will return wildcard addresses (0.0.0.0 and ::).

`static` when enabled will ensure we only return static ip's configured.

Returns a list of dicts - eg -

[

	{
	    "type": "INET6",
	    "address": "fe80::5054:ff:fe16:4aac",
	    "netmask": 64
	},
	{
	    "type": "INET",
	    "address": "192.168.122.148",
	    "netmask": 24,
	    "broadcast": "192.168.122.255"
	},

]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInterfaceIpInUsePostRequest
*/
func (a *InterfaceApiService) InterfaceIpInUsePost(ctx context.Context) ApiInterfaceIpInUsePostRequest {
	return ApiInterfaceIpInUsePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *InterfaceApiService) InterfaceIpInUsePostExecute(r ApiInterfaceIpInUsePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InterfaceApiService.InterfaceIpInUsePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interface/ip_in_use"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.interfaceIpInUse0
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInterfaceLacpduRateChoicesGetRequest struct {
	ctx        context.Context
	ApiService *InterfaceApiService
}

func (r ApiInterfaceLacpduRateChoicesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.InterfaceLacpduRateChoicesGetExecute(r)
}

/*
InterfaceLacpduRateChoicesGet Method for InterfaceLacpduRateChoicesGet

Available lacpdu rate policies for the LACP lagg type interfaces.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInterfaceLacpduRateChoicesGetRequest
*/
func (a *InterfaceApiService) InterfaceLacpduRateChoicesGet(ctx context.Context) ApiInterfaceLacpduRateChoicesGetRequest {
	return ApiInterfaceLacpduRateChoicesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *InterfaceApiService) InterfaceLacpduRateChoicesGetExecute(r ApiInterfaceLacpduRateChoicesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InterfaceApiService.InterfaceLacpduRateChoicesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interface/lacpdu_rate_choices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInterfaceLagPortsChoicesPostRequest struct {
	ctx        context.Context
	ApiService *InterfaceApiService
	body       *string
}

func (r ApiInterfaceLagPortsChoicesPostRequest) Body(body string) ApiInterfaceLagPortsChoicesPostRequest {
	r.body = &body
	return r
}

func (r ApiInterfaceLagPortsChoicesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.InterfaceLagPortsChoicesPostExecute(r)
}

/*
InterfaceLagPortsChoicesPost Method for InterfaceLagPortsChoicesPost

Return available interface choices that can be added to a `bond` (lag) interface.

`id` is name of existing bond interface on the system that will have its member

	       interfaces included.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInterfaceLagPortsChoicesPostRequest
*/
func (a *InterfaceApiService) InterfaceLagPortsChoicesPost(ctx context.Context) ApiInterfaceLagPortsChoicesPostRequest {
	return ApiInterfaceLagPortsChoicesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *InterfaceApiService) InterfaceLagPortsChoicesPostExecute(r ApiInterfaceLagPortsChoicesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InterfaceApiService.InterfaceLagPortsChoicesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interface/lag_ports_choices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInterfacePostRequest struct {
	ctx              context.Context
	ApiService       *InterfaceApiService
	interfaceCreate0 *InterfaceCreate0
}

func (r ApiInterfacePostRequest) InterfaceCreate0(interfaceCreate0 InterfaceCreate0) ApiInterfacePostRequest {
	r.interfaceCreate0 = &interfaceCreate0
	return r
}

func (r ApiInterfacePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.InterfacePostExecute(r)
}

/*
InterfacePost Method for InterfacePost

Create virtual interfaces (Link Aggregation, VLAN)

For BRIDGE `type` the following attribute is required: bridge_members.

For LINK_AGGREGATION `type` the following attributes are required: lag_ports,
lag_protocol.

For VLAN `type` the following attributes are required: vlan_parent_interface,
vlan_tag and vlan_pcp.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInterfacePostRequest
*/
func (a *InterfaceApiService) InterfacePost(ctx context.Context) ApiInterfacePostRequest {
	return ApiInterfacePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *InterfaceApiService) InterfacePostExecute(r ApiInterfacePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InterfaceApiService.InterfacePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interface"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.interfaceCreate0
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInterfaceRollbackGetRequest struct {
	ctx        context.Context
	ApiService *InterfaceApiService
}

func (r ApiInterfaceRollbackGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.InterfaceRollbackGetExecute(r)
}

/*
InterfaceRollbackGet Method for InterfaceRollbackGet

Rollback pending interfaces changes.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInterfaceRollbackGetRequest
*/
func (a *InterfaceApiService) InterfaceRollbackGet(ctx context.Context) ApiInterfaceRollbackGetRequest {
	return ApiInterfaceRollbackGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *InterfaceApiService) InterfaceRollbackGetExecute(r ApiInterfaceRollbackGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InterfaceApiService.InterfaceRollbackGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interface/rollback"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInterfaceSaveDefaultRoutePostRequest struct {
	ctx        context.Context
	ApiService *InterfaceApiService
	body       *string
}

func (r ApiInterfaceSaveDefaultRoutePostRequest) Body(body string) ApiInterfaceSaveDefaultRoutePostRequest {
	r.body = &body
	return r
}

func (r ApiInterfaceSaveDefaultRoutePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.InterfaceSaveDefaultRoutePostExecute(r)
}

/*
InterfaceSaveDefaultRoutePost Method for InterfaceSaveDefaultRoutePost

This method exists _solely_ to provide a "warning" and therefore
a path for remediation for when an end-user modifies an interface
and we rip the default gateway out from underneath them without
any type of warning.

NOTE: This makes 2 assumptions
 1. interface.create/update/delete must have been called before
    calling this method
 2. this method must be called before `interface.sync` is called

This method exists for the predominant scenario for new users...
 1. fresh install SCALE
 2. all interfaces start DHCPv4 (v6 is ignored for now)
 3. 1 of the interfaces receives an IP address
 4. along with the IP, the kernel receives a default route
    (by design, of course)
 5. user goes to configure this interface as having a static
    IP address
 6. as we go through and "sync" the changes, we remove the default
    route because it exists in the kernel FIB but doesn't exist
    in the database.
 7. IF the user is connecting via layer3, then they will lose all
    access to the TrueNAS and never be able to finalize the changes
    to the network because we ripped out the default route which
    is how they were communicating to begin with.

In the above scenario, we're going to try and prevent this by doing
the following:
 1. fresh install SCALE
 2. all interfaces start DHCPv4
 3. default route is received
 4. user configures an interface
 5. When user pushes "Test Changes" (interface.sync), webUI will call
    network.configuration.default_route_will_be_removed BEFORE interface.sync
 6. if network.configuration.default_route_will_be_removed returns True,
    then webUI will open a new modal dialog that gives the end-user
    ample warning/verbiage describing the situation. Furthermore, the
    modal will allow the user to input a default gateway
 7. if user gives gateway, webUI will call this method providing the info
    and we'll validate accordingly
 8. OR if user doesn't give gateway, they will need to "confirm" this is
    desired
 9. the default gateway provided to us (if given by end-user) will be stored
    in the same in-memory cache that we use for storing the interface changes
    and will be rolledback accordingly in this plugin just like everything else

There are a few other scenarios where this is beneficial, but the one listed above
is seen most often by end-users/support team.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInterfaceSaveDefaultRoutePostRequest
*/
func (a *InterfaceApiService) InterfaceSaveDefaultRoutePost(ctx context.Context) ApiInterfaceSaveDefaultRoutePostRequest {
	return ApiInterfaceSaveDefaultRoutePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *InterfaceApiService) InterfaceSaveDefaultRoutePostExecute(r ApiInterfaceSaveDefaultRoutePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InterfaceApiService.InterfaceSaveDefaultRoutePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interface/save_default_route"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInterfaceServicesRestartedOnSyncGetRequest struct {
	ctx        context.Context
	ApiService *InterfaceApiService
}

func (r ApiInterfaceServicesRestartedOnSyncGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.InterfaceServicesRestartedOnSyncGetExecute(r)
}

/*
InterfaceServicesRestartedOnSyncGet Method for InterfaceServicesRestartedOnSyncGet

Returns which services will be set to listen on 0.0.0.0 (and, thus, restarted) on sync.

Example result:
[

	// Samba service will be set ot listen on 0.0.0.0 and restarted because it was set up to listen on
	// 192.168.0.1 which is being removed.
	{"type": "SYSTEM_SERVICE", "service": "cifs", "ips": ["192.168.0.1"]},

]

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInterfaceServicesRestartedOnSyncGetRequest
*/
func (a *InterfaceApiService) InterfaceServicesRestartedOnSyncGet(ctx context.Context) ApiInterfaceServicesRestartedOnSyncGetRequest {
	return ApiInterfaceServicesRestartedOnSyncGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *InterfaceApiService) InterfaceServicesRestartedOnSyncGetExecute(r ApiInterfaceServicesRestartedOnSyncGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InterfaceApiService.InterfaceServicesRestartedOnSyncGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interface/services_restarted_on_sync"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInterfaceVlanParentInterfaceChoicesGetRequest struct {
	ctx        context.Context
	ApiService *InterfaceApiService
}

func (r ApiInterfaceVlanParentInterfaceChoicesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.InterfaceVlanParentInterfaceChoicesGetExecute(r)
}

/*
InterfaceVlanParentInterfaceChoicesGet Method for InterfaceVlanParentInterfaceChoicesGet

Return available interface choices for `vlan_parent_interface` attribute.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInterfaceVlanParentInterfaceChoicesGetRequest
*/
func (a *InterfaceApiService) InterfaceVlanParentInterfaceChoicesGet(ctx context.Context) ApiInterfaceVlanParentInterfaceChoicesGetRequest {
	return ApiInterfaceVlanParentInterfaceChoicesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *InterfaceApiService) InterfaceVlanParentInterfaceChoicesGetExecute(r ApiInterfaceVlanParentInterfaceChoicesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InterfaceApiService.InterfaceVlanParentInterfaceChoicesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interface/vlan_parent_interface_choices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInterfaceXmitHashPolicyChoicesGetRequest struct {
	ctx        context.Context
	ApiService *InterfaceApiService
}

func (r ApiInterfaceXmitHashPolicyChoicesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.InterfaceXmitHashPolicyChoicesGetExecute(r)
}

/*
InterfaceXmitHashPolicyChoicesGet Method for InterfaceXmitHashPolicyChoicesGet

Available transmit hash policies for the LACP or LOADBALANCE
lagg type interfaces.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInterfaceXmitHashPolicyChoicesGetRequest
*/
func (a *InterfaceApiService) InterfaceXmitHashPolicyChoicesGet(ctx context.Context) ApiInterfaceXmitHashPolicyChoicesGetRequest {
	return ApiInterfaceXmitHashPolicyChoicesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *InterfaceApiService) InterfaceXmitHashPolicyChoicesGetExecute(r ApiInterfaceXmitHashPolicyChoicesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InterfaceApiService.InterfaceXmitHashPolicyChoicesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/interface/xmit_hash_policy_choices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
